export default [
    "{ filename: \"src/MeCamera.cpp\", code: \"/**\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\n * \\\\class   MeCamera\\n * \\\\brief   Driver for MeCamera module.\\n * @file    MeCamera.cpp\\n * @author  MakeBlock\\n * @version V1.0.0\\n * @date    2017/09/26\\n * @brief   Driver for MeCamera module.\\n *\\n * \\\\par Copyright\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\n *\\n * \\\\par Open Source Licensing GPL V2\\n * This is the appropriate option if you want to share the source code of your \\\\n\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\n *\\n * \\\\par Description\\n * This file is a drive for MeCamera module, It supports MeCamera V1.0 device provided\\n * by MakeBlock.\\n *\\n * \\\\par Method List:\\n *\\n *    1.void MeCamera::setpin(uint8_t AD0, uint8_t INT)\\n *    2.void MeCamera::begin(void)\\n *\\n * \\\\par History:\\n * <pre>\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\n *  Payton            2017/09/26        1.0.0         rebuild the old lib.\\n * </pre>\\n *\\n * @example CameraTest.ino\\n */\\n\\n/* Includes ------------------------------------------------------------------*/\\n#include \\\"MeCamera.h\\\"\\n\\n#include <Arduino.h>\\n\\n/* Private functions ---------------------------------------------------------*/\\n#ifdef ME_PORT_DEFINED\\n/**\\n * Alternate Constructor which can call your own function to map the MeCamera to arduino port\\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\\n * \\\\param[in]\\n *   port - RJ25 port from PORT_1 to PORT_4\\n */\\nMeCamera::MeCamera(uint8_t port) : MePort(port)\\n{\\n  //address0-11, address1-10, address2-01, address3-00\\n  pinMode(s1, OUTPUT);\\n  pinMode(s2, OUTPUT);\\n  if(port == PORT_1)\\n  {\\n    digitalWrite(s1,LOW);\\n    digitalWrite(s2,LOW);\\n    Device_Address = CAMERA_DEFAULT_ADDRESS + 0;\\n  }\\n  else if(port == PORT_2)\\n  {\\n    digitalWrite(s1,HIGH);\\n    digitalWrite(s2,LOW);\\n    Device_Address = CAMERA_DEFAULT_ADDRESS + 1;\\n  }\\n  else if(port == PORT_3)\\n  {\\n    digitalWrite(s1,LOW);\\n    digitalWrite(s2,HIGH);\\n    Device_Address = CAMERA_DEFAULT_ADDRESS + 2;\\n  }\\n  else if(port == PORT_4)\\n  {\\n    digitalWrite(s1,HIGH);\\n    digitalWrite(s2,HIGH);\\n    Device_Address = CAMERA_DEFAULT_ADDRESS + 3;\\n  }\\n  else\\n  { \\n    digitalWrite(s1,LOW);\\n    digitalWrite(s2,LOW);\\n    Device_Address = CAMERA_DEFAULT_ADDRESS + 0;\\n  }\\n}\\n#else  // ME_PORT_DEFINED\\n/**\\n * Alternate Constructor which can call your own function to map the AD0 and INT to arduino port,\\n * no pins are used or initialized here\\n * \\\\param[in]\\n *   AD0 - arduino gpio number\\n * \\\\param[in]\\n *   INT - arduino gpio number\\n */\\nMeCamera::MeCamera(uint8_t AD0, uint8_t INT)\\n{\\n  pinMode(AD0,OUTPUT);\\n  pinMode(INT,OUTPUT);\\n\\n  digitalWrite(AD0,LOW);\\n  digitalWrite(INT,LOW);\\n  Device_Address = CAMERA_DEFAULT_ADDRESS + 0;\\n}\\n\\n#endif // ME_PORT_DEFINED\\n\\n/**\\n * \\\\par Function\\n *   setpin\\n * \\\\par Description\\n *   Set the PIN of the button module.\\n * \\\\param[in]\\n *   AD0 - pin mapping for arduino\\n * \\\\param[in]\\n *   INT - pin mapping for arduino\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None.\\n * \\\\par Others\\n *   Set global variable AD0, INT, s1 and s2\\n */\\nvoid MeCamera::setpin(uint8_t AD0, uint8_t INT)\\n{\\n  pinMode(AD0,OUTPUT);\\n  pinMode(INT,OUTPUT);\\n\\n#ifdef ME_PORT_DEFINED\\n  s1 = AD0;\\n  s2 = INT;\\n#endif // ME_PORT_DEFINED\\n}\\n\\n/**\\n * \\\\par Function\\n *   begin\\n * \\\\par Description\\n *   Initialize the MeCamera.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n *   \\n */\\nvoid MeCamera::begin(void)\\n{\\n  motor_diff_speed = 0;\\n  kp = 0.5;\\n  pixy_work_mode = IDLE_MODE;\\n  led_change_flag = 1;\\n  \\n  Wire.begin();\\n  delay(50);\\n}\\n\\n/**\\n * \\\\par Function\\n *   setCameraMode\\n * \\\\par Description\\n *   Set pixy2 work in mode: IDLE_MODE / CCC_MODE / LINE_MODE / VIDEO_MODE\\n *   Setting mode delay time 500ms ~ 1500ms.\\n * \\\\param[in]\\n *   mode: IDLE_MODE / CCC_MODE / LINE_MODE / VIDEO_MODE\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   0: set mode sucess\\n *   -1:set mode fail\\n * \\\\par Others\\n */\\nint8_t MeCamera::setCameraMode(uint8_t mode)\\n{\\n  int8_t return_value = 0;\\n  int8_t count = 3;\\n\\n  if(mode != pixy_work_mode)\\n  {\\n    led_change_flag = 1;\\n  }\\n\\n  while(count--)\\n  {\\n    //Serial.println(\\\"SET_PIXY_MODE\\\");\\n    writeData(SET_PIXY_MODE, &mode, 1);\\n    delay(500);\\n\\n    return_value = readData(SET_PIXY_MODE, &i2cData[0], 1);\\n    if((i2cData[0] == mode) && (return_value == I2C_OK))\\n    {\\n      pixy_work_mode = mode;\\n      motor_diff_speed = 0;\\n      return 0;\\n    }\\n  }\\n  return -1;\\n}\\n\\n/**\\n * \\\\par Function\\n *   setLineMode\\n * \\\\par Description\\n *   Set line follow mode\\n * \\\\param[in]\\n *   mode: \\n *   0 - find dark lines on a light background (black lines)\\n  *  1 - find light lines on a dark background (white lines)\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   0: set mode sucess\\n *   -1:set mode fail\\n * \\\\par Others\\n */\\nint8_t MeCamera::setLineMode(uint8_t mode)\\n{\\n  int8_t return_value = 0;\\n  int8_t count = 3;\\n\\n  while(count--)\\n  {\\n    return_value = writeData(SET_LINE_FOLLOW_MODE, &mode, 1);\\n    delay(2);\\n    if(return_value == I2C_OK)\\n    {\\n      readData(SET_LINE_FOLLOW_MODE, &i2cData[0], 1);\\n      if(i2cData[0] == mode)\\n      {\\n        return 0;\\n      }\\n    }\\n  }\\n  return -1;\\n}\\n\\n/**\\n * \\\\par Function\\n *   setLED\\n * \\\\par Description\\n *   Set Supplementary lamp status\\n * \\\\param[in]\\n *   onOff: \\n *   0 - Turn off the supplementary light\\n  *  1 - Turn on the supplementary light\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   0: set sucess\\n *   -1:set fail\\n * \\\\par Others\\n */\\nint8_t MeCamera::setLED(uint8_t onOff)\\n{\\n  int8_t return_value = 0;\\n  int8_t count = 3;\\n  uint8_t data = 1;\\n\\n  if(led_change_flag == 1)\\n  {\\n    return_value = writeData(SET_LED, &data, 1);\\n    led_change_flag = 0;\\n  }\\n  while(count--)\\n  {\\n    return_value = writeData(SET_LED, &onOff, 1);\\n    delay(2);\\n    if(return_value == I2C_OK)\\n    {\\n      readData(SET_LED, &i2cData[0], 1);\\n      if(i2cData[0] == onOff)\\n      {\\n        return 0;\\n      }\\n    }\\n  }\\n  return -1;\\n}\\n\\n/**\\n * \\\\par Function\\n *   startStudyCCC\\n * \\\\par Description\\n *   Start enter study CCC\\n * \\\\param[in]\\n *    sig - color signatures, numbered 1-7\\n *    times - study timeout ,unit 1s\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   0: study sucess\\n *   -1:study fail\\n * \\\\par Others\\n */\\nint8_t MeCamera::startStudyCCC(uint8_t sig, uint8_t times)\\n{\\n  int8_t return_value = 0;\\n  uint8_t buff[2];\\n\\n  buff[0] = sig - 1;\\n  buff[1] = times;\\n\\n  return_value = writeData(SET_START_STUDY, &buff[0], 2);\\n  delay(100);\\n\\n  while(1)\\n  {\\n    return_value = readData(GET_STUDY_STATE_ADDR, &i2cData[0], 1);\\n    if(return_value == I2C_OK)\\n    {\\n      if(i2cData[0] == 0)\\n      {\\n        //Serial.println(\\\"startStudyCCC\\\");\\n        delay(2000);\\n        return 0;\\n      }\\n    }\\n    else\\n    {\\n      break;\\n    }\\n    delay(100);\\n  }\\n  return -1;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getCCCValue\\n * \\\\par Description\\n *   get CCC value\\n * \\\\param[in]\\n *   sig - color signatures, numbered 1-7\\n *   type - data type, CCC_X/CCC_Y/CCC_W/CCC_H\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the value of CCC:\\n *    - x-axis value ranges between 0 and 319\\n *    - y-axis value ranges between 0 and 239\\n *    - width value ranges between 0 and 320\\n *    - height value ranges between 0 and 240\\n * \\\\par Others\\n */\\nuint16_t MeCamera::getCCCValue(uint8_t sig, uint8_t type)\\n{\\n  int8_t return_value;\\n  uint32_t data = 0;\\n\\n  if(type == CCC_NUM)\\n  {\\n    return_value = readPixy2Data(CCC_NUM_ADDR, &i2cData[0], 1);\\n  }\\n  else\\n  {\\n    return_value = readPixy2Data(CCC1_X_LOW_ADDR + (sig-1)*12 + type*2, &i2cData[0], 2);\\n  }\\n\\n  if(return_value == I2C_OK)\\n  {\\n    data = *(uint16_t*)&i2cData[0];\\n  }\\n\\n  if(type == CCC_X || type == CCC_W)\\n  {\\n    data = data * 320 / 316;\\n  }\\n  else if(type == CCC_Y || type == CCC_H)\\n  {\\n    data = data * 240 / 208;\\n  }\\n  return (uint16_t)data;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getVectorValue\\n * \\\\par Description\\n *   get the value of the Vector or line\\n * \\\\param[in]\\n *   type - data type, VECTOR_X0/VECTOR_Y0/VECTOR_X1/VECTOR_Y1\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the value of the vector:\\n *   - x0 value ranges between 0 and 319\\n *   - y0 value ranges between 0 and 239\\n *   - x1 value ranges between 0 and 319\\n *   - y1 value ranges between 0 and 239\\n * \\\\par Others\\n */\\nuint16_t MeCamera::getVectorValue(uint8_t type)\\n{\\n  int8_t return_value;\\n  uint32_t data = 0;\\n  \\n  return_value = readPixy2Data(LINE_X0_ADDR + type, &i2cData[0], 1);\\n  if(return_value == I2C_OK)\\n  {\\n    data = *(uint8_t*)&i2cData[0];\\n  }\\n\\n  if(type == VECTOR_X0 || type == VECTOR_X1)\\n  {\\n    data = data * 320 / 78;\\n  }\\n  else if(type == VECTOR_Y0 || type == VECTOR_Y1)\\n  {\\n    data = data * 240 / 52;\\n  }\\n  return (uint16_t)data;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getIntersectionValue\\n * \\\\par Description\\n *   get the value of the intersection\\n * \\\\param[in]\\n *   type - data type, INTERSECTION_X/INTERSECTION_Y/INTERSECTION_NUM\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the value of the intersection:\\n *   - x-axis value ranges between 0 and 319\\n *   - y-axis value ranges between 0 and 239\\n *   - num the number of lines (branches), ranges between 0 and 6\\n * \\\\par Others\\n */\\nuint16_t MeCamera::getIntersectionValue(uint8_t type)\\n{\\n  int8_t return_value;\\n  uint32_t data = 0;\\n  \\n  return_value = readPixy2Data(INTERSECTION_X_ADDR + type, &i2cData[0], 1);\\n  if(return_value == I2C_OK)\\n  {\\n    data = *(uint8_t*)&i2cData[0];\\n  }\\n\\n  if(type == INTERSECTION_X)\\n  {\\n    data = data * 320 / 78;\\n  }\\n  else if(type == INTERSECTION_Y)\\n  {\\n    data = data * 240 / 52;\\n  }\\n  return (uint16_t)data;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getIntersectionAngle\\n * \\\\par Description\\n *   get the angle in degrees of the line\\n * \\\\param[in]\\n *   index: the tracking index of the line, 1 ~ 6\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the angle in degrees of the line, The value ranges between -180 and 180\\n * \\\\par Others\\n */\\nint16_t MeCamera::getIntersectionAngle(uint8_t index)\\n{\\n  int8_t return_value;\\n  int16_t data = 0;\\n\\n  if(index < 1 || index > 6)\\n  {\\n    return 0;\\n  }\\n  \\n  return_value = readPixy2Data(INTERSECTION_LINE1_ANGLE_LOW_ADDR + (index-1)*2  , &i2cData[0], 2);\\n  if(return_value == I2C_OK)\\n  {\\n    data = *(int16_t*)&i2cData[0];\\n  }\\n  return data;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getBarCodeValue\\n * \\\\par Description\\n *   get the value location of the barcode.\\n * \\\\param[in]\\n *   code - value of the code, The value ranges between 0 and 15\\n *   type - data type, BARCODE_X/BARCODE_Y\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   the value of the barcode:\\n *   - x-axis value ranges between 0 and 319\\n *   - y-axis value ranges between 0 and 239\\n * \\\\par Others\\n */\\nuint16_t MeCamera::getBarCodeValue(uint8_t code, uint8_t type)\\n{\\n  int8_t return_value;\\n  uint32_t data = 0;\\n\\n  if(type == BARCODE_NUM)\\n  {\\n    return_value = readPixy2Data(BARCODE_NUM_ADDR, &i2cData[0], 1);\\n  }\\n  else\\n  {\\n    return_value = readPixy2Data(BARCODE0_X_ADDR + code*2 + type, &i2cData[0], 1);\\n  }\\n\\n  if(return_value == I2C_OK)\\n  {\\n    data = *(uint8_t*)&i2cData[0];\\n  }\\n\\n  if(type == BARCODE_X)\\n  {\\n    data = data * 320 / 78;\\n  }\\n  else if(type == BARCODE_Y)\\n  {\\n    data = data * 240 / 52;\\n  }\\n  return (uint16_t)data;\\n}\\n\\n/**\\n * \\\\par Function\\n *   setMotorDiffSpeedKp\\n * \\\\par Description\\n *   Set left/right Motor differential speed sensitivity\\n * \\\\param[in]\\n *   kp: 0 ~ 1\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n */\\nvoid MeCamera::setMotorDiffSpeedKp(float _kp)\\n{\\n  if(_kp < 0)\\n  {\\n    kp = 0;\\n  }\\n  else  if(_kp > 1)\\n  {\\n    kp = 1;\\n  }\\n  else\\n  {\\n    kp = _kp;\\n  }\\n}\\n\\n/**\\n * \\\\par Function\\n *   getFollowColorValue\\n * \\\\par Description\\n *   When automatically following the color block: Get left/right Motor differential speed value\\n * \\\\param[in]\\n *    sig - color signatures, numbered 1-7\\n *   x - x axis location in the image, 0 ~ 319, -1 invalid\\n *   y - y axis location in the image, 0 ~ 239, -1 invalid\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Motor differential speed value: -100 ~ 100\\n * \\\\par Others\\n */\\nint16_t MeCamera::getFollowColorValue(uint8_t sig, int16_t x, int16_t y)\\n{\\n  int8_t return_value = 0;\\n  int32_t cur_x = 0, cur_y = 0;\\n  int16_t error = 0;\\n\\n  if(pixy_work_mode != CCC_MODE)\\n  {\\n    return 0;\\n  }\\n\\n  return_value = readPixy2Data(CCC1_X_LOW_ADDR + (sig-1)*12, &i2cData[0], 4);\\n  cur_x = *(int16_t*)&i2cData[0];\\n  cur_y = *(int16_t*)&i2cData[2];\\n  if(return_value != I2C_OK)\\n  {\\n    return 0;\\n  }\\n  if(cur_x == 0)\\n  {\\n    return 0;\\n  }\\n\\n  cur_x = cur_x * 320 / 316;\\n  cur_y = cur_y * 240 / 208;\\n  if(x == -1)\\n  {\\n    error = (int16_t)(y - cur_y) * 2;\\n  }\\n  else if(y == -1)\\n  {\\n    error = (int16_t)(cur_x - x) * 1;\\n  }\\n  else\\n  {\\n    return 0;\\n  }\\n\\n  error = constrain(error, -100, 100);\\n  error = error * kp;\\n  //LIMIT(error, 20);\\n\\n  motor_diff_speed = error;\\n  return motor_diff_speed;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getFollowBarcodeValue\\n * \\\\par Description\\n *   When automatically following the barcode: Get left/right Motor differential speed value\\n * \\\\param[in]\\n *   code - value of the barcode, The value ranges between 0 and 15\\n *   x - x axis location in the image, 0 ~ 319, -1 invalid\\n *   y - y axis location in the image, 0 ~ 239, -1 invalid\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Motor differential speed value: -100 ~ 100\\n * \\\\par Others\\n */\\nint16_t MeCamera::getFollowBarcodeValue(uint8_t code, int16_t x, int16_t y)\\n{\\n  int8_t return_value = 0;\\n  int32_t cur_x = 0, cur_y = 0;\\n  int16_t error = 0;\\n\\n  if(pixy_work_mode != LINE_MODE)\\n  {\\n    return 0;\\n  }\\n\\n  return_value = readPixy2Data(BARCODE0_X_ADDR + code*2, &i2cData[0], 2);\\n  cur_x = *(uint8_t*)&i2cData[0];\\n  cur_y = *(uint8_t*)&i2cData[1];\\n  if(return_value != I2C_OK)\\n  {\\n    return 0;\\n  }\\n  if(cur_x == 0)\\n  {\\n    return 0;\\n  }\\n\\n  cur_x = cur_x * 320 / 78;\\n  cur_y = cur_y * 240 / 52;\\n  if(x == -1)\\n  {\\n    error = (int16_t)(y - cur_y) * 2;\\n  }\\n  else if(y == -1)\\n  {\\n    error = (int16_t)(cur_x - x) * 1;\\n  }\\n  else\\n  {\\n    return 0;\\n  }\\n\\n  error = constrain(error, -100, 100);\\n  error = error * kp;\\n  //LIMIT(error, 20);\\n\\n  motor_diff_speed = error;\\n  return motor_diff_speed;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getFollowVectorValue\\n * \\\\par Description\\n *   When automatically following the vector: Get left/right Motor differential speed value\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Motor differential speed value: -100 ~ 100\\n * \\\\par Others\\n */\\nint16_t MeCamera::getFollowVectorValue(void)\\n{\\n  int8_t return_value = 0;\\n  int32_t x0, y0, x1, y1;\\n  int16_t error = 0;\\n\\n  if(pixy_work_mode != LINE_MODE)\\n  {\\n    return 0;\\n  }\\n\\n  return_value = readPixy2Data(LINE_X0_ADDR + VECTOR_X0, &i2cData[0], 4);\\n  x0 = *(uint8_t*)&i2cData[0];\\n  y0 = *(uint8_t*)&i2cData[1];\\n  x1 = *(uint8_t*)&i2cData[2];\\n  y1 = *(uint8_t*)&i2cData[3];\\n  if(return_value != I2C_OK)\\n  {\\n    return 0;\\n  }\\n  if(x0 == 0 && x1 == 0)\\n  {\\n    return 0;\\n  }\\n\\n  x0 = x0 * 320 / 78;\\n  y0 = y0 * 240 / 52;\\n  x1 = x1 * 320 / 78;\\n  y1 = y1 * 240 / 52;\\n\\n  error = (int16_t)(x0 - 160)*0.7 + (int16_t)(x1 - 160)*0.3;\\n  error = constrain(error, -100, 100);\\n  error = error * kp;\\n  //LIMIT(error, 20);\\n\\n  motor_diff_speed = error;\\n  return motor_diff_speed;\\n}\\n\\n/**\\n * \\\\par Function\\n *   isLockedCCC\\n * \\\\par Description\\n *   is locked the color block?\\n * \\\\param[in]\\n *   sig - color signatures, numbered 1-7\\n *   x - x axis location in the image, 0 ~ 319, -1 invalid\\n *   y - y axis location in the image, 0 ~ 239, -1 invalid\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   true - Lock the target position\\n *   false - No Lock the target position\\n * \\\\par Others\\n */\\nbool MeCamera::isLockedCCC(uint8_t sig, int16_t x, int16_t y)\\n{\\n  int8_t return_value = 0;\\n  int32_t cur_x = 0, cur_y = 0;\\n\\n  if(pixy_work_mode != CCC_MODE)\\n  {\\n    return false;\\n  }\\n\\n  return_value = readPixy2Data(CCC1_X_LOW_ADDR + (sig-1)*12, &i2cData[0], 4);\\n  cur_x = *(int16_t*)&i2cData[0];\\n  cur_y = *(int16_t*)&i2cData[2];\\n  if((return_value != I2C_OK) || (cur_x == 0))\\n  {\\n    return false;\\n  }\\n\\n  cur_x = cur_x * 320 / 316;\\n  cur_y = cur_y * 240 / 208;\\n  if(x == -1)\\n  {\\n    if(abs(cur_y - y) < 20)\\n    {\\n      return true;\\n    }\\n  }\\n  else if(y == -1)\\n  {\\n    if(abs(cur_x - x) < 20)\\n    {\\n      return true;\\n    }\\n  }\\n  else\\n  {\\n    if((abs(cur_y - y) < 20) && (abs(cur_x - x) < 20))\\n    {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\n/**\\n * \\\\par Function\\n *   isLockedBarcode\\n * \\\\par Description\\n *   is locked the Barcode?\\n * \\\\param[in]\\n *   code - value of the barcode, The value ranges between 0 and 15\\n *   x - x axis location in the image, 0 ~ 319, -1 invalid\\n *   y - y axis location in the image, 0 ~ 239, -1 invalid\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   true - Lock the target position\\n *   false - No Lock the target position\\n * \\\\par Others\\n */\\nbool MeCamera::isLockedBarcode(uint8_t code, int16_t x, int16_t y)\\n{\\n  int8_t return_value = 0;\\n  int32_t cur_x = 0, cur_y = 0;\\n\\n  if(pixy_work_mode != LINE_MODE)\\n  {\\n    return false;\\n  }\\n\\n  return_value = readPixy2Data(BARCODE0_X_ADDR + code*2, &i2cData[0], 2);\\n  cur_x = *(uint8_t*)&i2cData[0];\\n  cur_y = *(uint8_t*)&i2cData[1];\\n  if((return_value != I2C_OK) || (cur_x == 0))\\n  {\\n    return false;\\n  }\\n\\n  cur_x = cur_x * 320 / 78;\\n  cur_y = cur_y * 240 / 52;\\n  if(x == -1)\\n  {\\n    if(abs(cur_y - y) < 20)\\n    {\\n      return true;\\n    }\\n  }\\n  else if(y == -1)\\n  {\\n    if(abs(cur_x - x) < 20)\\n    {\\n      return true;\\n    }\\n  }\\n  else\\n  {\\n    if((abs(cur_y - y) < 20) && (abs(cur_x - x) < 20))\\n    {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n}\\n\\n/**\\n * \\\\par Function\\n *   writeReg\\n * \\\\par Description\\n *   Write the registor of i2c device.\\n * \\\\param[in]\\n *   reg - the address of registor.\\n * \\\\param[in]\\n *   data - the data that will be written to the registor.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   To set the registor for initializing.\\n */\\nint8_t MeCamera::writeReg(uint8_t reg, uint8_t data)\\n{\\n  int8_t return_value = 0;\\n  return_value = writeData(reg, &data, 1);\\n  return(return_value);\\n}\\n\\n/**\\n * \\\\par Function\\n *   readData\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to read data.\\n */\\nint8_t MeCamera::readData(uint8_t start, uint8_t *buffer, uint8_t size)\\n{\\n  int16_t i = 0;\\n  int8_t return_value = 0;\\n\\n  Wire.beginTransmission(Device_Address);\\n  return_value = Wire.write(start);\\n  if(return_value != 1)\\n  {\\n    return(I2C_ERROR);\\n  }\\n  return_value = Wire.endTransmission(false);\\n  if(return_value != 0)\\n  {\\n    return(return_value);\\n  }\\n  delayMicroseconds(1);\\n  /* Third parameter is true: relase I2C-bus after data is read. */\\n  Wire.requestFrom(Device_Address, size, (uint8_t)true);\\n  while(Wire.available() && i < size)\\n  {\\n    buffer[i++] = Wire.read();\\n  }\\n  return_value = Wire.endTransmission(true);\\n  delayMicroseconds(1);\\n  if(i != size)\\n  {\\n    return(I2C_ERROR);\\n  }\\n  return(0); //return: no error \\n}\\n\\n/**\\n * \\\\par Function\\n *   readPixy2Data\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to read data.\\n */\\nint8_t MeCamera::readPixy2Data(uint8_t start, uint8_t *buffer, uint8_t size)\\n{\\n  int8_t return_value;\\n\\n  return_value = writeReg(start, 0x00);\\n  if(return_value == I2C_OK)\\n  {\\n    delay(2);\\n    return_value = readData(start, &buffer[0], size);\\n    if(return_value == I2C_OK)\\n    {\\n      return return_value;\\n    }\\n  }\\n  return(I2C_ERROR);\\n}\\n\\n/**\\n * \\\\par Function\\n *   writeData\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to write data.\\n */\\nint8_t MeCamera::writeData(uint8_t start, const uint8_t *pData, uint8_t size)\\n{\\n  int8_t return_value = 0;\\n  Wire.beginTransmission(Device_Address);\\n  return_value = Wire.write(start);\\n  if(return_value != 1)\\n  {\\n    return(I2C_ERROR);\\n  }\\n  Wire.write(pData, size);\\n  return_value = Wire.endTransmission(true);\\n  return(return_value); //return: no error                     \\n}\" }",
    "{ filename: \"src/MeCamera.h\", code: \"/**\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\n * \\\\class   MeCamera\\n * \\\\brief   Driver for MeCamera module.\\n * @file   MeCamera.h\\n * @author  MakeBlock\\n * @version V1.0.0\\n * @date    2017/09/26\\n * @brief   Header for MeCamera.cpp module.\\n *\\n * \\\\par Copyright\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\n *\\n * \\\\par Open Source Licensing GPL V2\\n * This is the appropriate option if you want to share the source code of your \\\\n\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\n *\\n * \\\\par Description\\n * This file is a drive for MeCamera module, It supports MeCamera V1.0 device provided\\n * by MakeBlock.\\n *\\n * \\\\par Method List:\\n *\\n *    1.void MeCamera::setpin(uint8_t AD0, uint8_t INT)\\n *    2.void MeCamera::begin(void)\\n *\\n * \\\\par History:\\n * <pre>\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\n *  Payton            2017/09/26          1.0.0         rebuild the old lib.\\n * </pre>\\n *\\n */\\n\\n/* Define to prevent recursive inclusion -------------------------------------*/\\n#ifndef MeCamera_H\\n#define MeCamera_H\\n\\n/* Includes ------------------------------------------------------------------*/\\n#include <stdint.h>\\n#include <stdbool.h>\\n#include <Arduino.h>\\n#include \\\"MeConfig.h\\\"\\n#ifdef ME_PORT_DEFINED\\n#include \\\"MePort.h\\\"\\n#endif // ME_PORT_DEFINED\\n\\n/* Exported macro ------------------------------------------------------------*/\\n#define I2C_ERROR                  \\t\\t\\t\\t\\t\\t(-1)\\n#define I2C_OK                    \\t\\t\\t\\t\\t\\t(0)\\n#define CAMERA_DEFAULT_ADDRESS        (0x25)\\n#define CAMERA_DEVICE_ID\\t\\t\\t\\t\\t\\t\\t(0xC1)\\n\\n#define CAMERA_NONE_DATA              (0x1F)\\n#define CAMERA_NONE_BIG_DATA          (0x1F1F)\\n\\n// pixy work mode\\n#define IDLE_MODE  0\\n#define CCC_MODE    1\\n#define LINE_MODE   2\\n#define VIDEO_MODE  3\\n\\n// SIG INDEX\\n#define SIG1    1\\n#define SIG2    2\\n#define SIG3    3\\n#define SIG4    4\\n#define SIG5    5\\n#define SIG6    6\\n#define SIG7    7\\n\\n//CCC value type\\n#define  CCC_X   0\\n#define  CCC_Y   1\\n#define  CCC_W   2\\n#define  CCC_H   3\\n#define  CCC_NUM   4\\n\\n//Vector value type\\n#define  VECTOR_X0   0\\n#define  VECTOR_Y0   1\\n#define  VECTOR_X1   2\\n#define  VECTOR_Y1   3\\n\\n//intersection value type\\n#define  INTERSECTION_X       0\\n#define  INTERSECTION_Y       1\\n#define  INTERSECTION_NUM     2\\n\\n//barcode value type\\n#define  BARCODE_X         0\\n#define  BARCODE_Y         1\\n#define  BARCODE_NUM       2\\n\\n//video value type\\n#define  VIDEO_R         0\\n#define  VIDEO_G         1\\n#define  VIDEO_B         2\\n\\n\\n#define LIMIT(x, a) if( (((x) >= 0) && ((x) < (a))) ) (x) = a;\\\\\\n                    else if( (((x) < 0) && ((x) >= -(a))) ) (x) = -a;\\n\\n\\n//Camera IIC Register Address\\n#define CAMERA_DEVICE_ID_ADDR   (0x01)\\n#define  CCC1_X_LOW_ADDR        0X01\\n#define  CCC1_X_HIGH_ADDR       0X02\\n#define  CCC1_Y_LOW_ADDR        0X03\\n#define  CCC1_Y_HIGH_ADDR       0X04\\n#define  CCC1_W_LOW_ADDR        0X05\\n#define  CCC1_W_HIGH_ADDR       0X06\\n#define  CCC1_H_LOW_ADDR        0X07\\n#define  CCC1_H_HIGH_ADDR       0X08\\n#define  CCC1_ANGLE_LOW_ADDR    0X09\\n#define  CCC1_ANGLE_HIGH_ADDR   0X0A\\n#define  CCC1_INDEX_LOW_ADDR    0X0B\\n#define  CCC1_INDEX_HIGH_ADDR   0X0C\\n#define  CCC2_X_LOW_ADDR        0X0D\\n#define  CCC2_X_HIGH_ADDR       0X0E\\n#define  CCC2_Y_LOW_ADDR        0X0F\\n#define  CCC2_Y_HIGH_ADDR       0X10\\n#define  CCC2_W_LOW_ADDR        0X11\\n#define  CCC2_W_HIGH_ADDR       0X12\\n#define  CCC2_H_LOW_ADDR        0X13\\n#define  CCC2_H_HIGH_ADDR       0X14\\n#define  CCC2_ANGLE_LOW_ADDR    0X15\\n#define  CCC2_ANGLE_HIGH_ADDR   0X16\\n#define  CCC2_INDEX_LOW_ADDR    0X17\\n#define  CCC2_INDEX_HIGH_ADDR   0X18\\n#define  CCC3_X_LOW_ADDR        0X19\\n#define  CCC3_X_HIGH_ADDR       0X1A\\n#define  CCC3_Y_LOW_ADDR        0X1B\\n#define  CCC3_Y_HIGH_ADDR       0X1C\\n#define  CCC3_W_LOW_ADDR        0X1D\\n#define  CCC3_W_HIGH_ADDR       0X1E\\n#define  CCC3_H_LOW_ADDR        0X1F\\n#define  CCC3_H_HIGH_ADDR       0X20\\n#define  CCC3_ANGLE_LOW_ADDR    0X21\\n#define  CCC3_ANGLE_HIGH_ADDR   0X22\\n#define  CCC3_INDEX_LOW_ADDR    0X23\\n#define  CCC3_INDEX_HIGH_ADDR   0X24\\n#define  CCC4_X_LOW_ADDR        0X25\\n#define  CCC4_X_HIGH_ADDR       0X26\\n#define  CCC4_Y_LOW_ADDR        0X27\\n#define  CCC4_Y_HIGH_ADDR       0X28\\n#define  CCC4_W_LOW_ADDR        0X29\\n#define  CCC4_W_HIGH_ADDR       0X2A\\n#define  CCC4_H_LOW_ADDR        0X2B\\n#define  CCC4_H_HIGH_ADDR       0X2C\\n#define  CCC4_ANGLE_LOW_ADDR    0X2D\\n#define  CCC4_ANGLE_HIGH_ADDR   0X2E\\n#define  CCC4_INDEX_LOW_ADDR    0X2F\\n#define  CCC4_INDEX_HIGH_ADDR   0X30\\n#define  CCC5_X_LOW_ADDR        0X31\\n#define  CCC5_X_HIGH_ADDR       0X32\\n#define  CCC5_Y_LOW_ADDR        0X33\\n#define  CCC5_Y_HIGH_ADDR       0X34\\n#define  CCC5_W_LOW_ADDR        0X35\\n#define  CCC5_W_HIGH_ADDR       0X36\\n#define  CCC5_H_LOW_ADDR        0X37\\n#define  CCC5_H_HIGH_ADDR       0X38\\n#define  CCC5_ANGLE_LOW_ADDR    0X39\\n#define  CCC5_ANGLE_HIGH_ADDR   0X3A\\n#define  CCC5_INDEX_LOW_ADDR    0X3B\\n#define  CCC5_INDEX_HIGH_ADDR   0X3C\\n#define  CCC6_X_LOW_ADDR        0X3D\\n#define  CCC6_X_HIGH_ADDR       0X3E\\n#define  CCC6_Y_LOW_ADDR        0X3F\\n#define  CCC6_Y_HIGH_ADDR       0X40\\n#define  CCC6_W_LOW_ADDR        0X41\\n#define  CCC6_W_HIGH_ADDR       0X42\\n#define  CCC6_H_LOW_ADDR        0X43\\n#define  CCC6_H_HIGH_ADDR       0X44\\n#define  CCC6_ANGLE_LOW_ADDR    0X45\\n#define  CCC6_ANGLE_HIGH_ADDR   0X46\\n#define  CCC6_INDEX_LOW_ADDR    0X47\\n#define  CCC6_INDEX_HIGH_ADDR   0X48\\n#define  CCC7_X_LOW_ADDR        0X49\\n#define  CCC7_X_HIGH_ADDR       0X4A\\n#define  CCC7_Y_LOW_ADDR        0X4B\\n#define  CCC7_Y_HIGH_ADDR       0X4C\\n#define  CCC7_W_LOW_ADDR        0X4D\\n#define  CCC7_W_HIGH_ADDR       0X4E\\n#define  CCC7_H_LOW_ADDR        0X4F\\n#define  CCC7_H_HIGH_ADDR       0X50\\n#define  CCC7_ANGLE_LOW_ADDR    0X51\\n#define  CCC7_ANGLE_HIGH_ADDR   0X52\\n#define  CCC7_INDEX_LOW_ADDR    0X53\\n#define  CCC7_INDEX_HIGH_ADDR   0X54\\n#define  CCC_NUM_ADDR           0X55\\n\\n#define LINE_X0_ADDR            0X56\\n#define LINE_Y0_ADDR            0X57\\n#define LINE_X1_ADDR            0X58\\n#define LINE_Y1_ADDR            0X59\\n\\n#define INTERSECTION_X_ADDR     0X5A\\n#define INTERSECTION_Y_ADDR     0X5B\\n#define INTERSECTION_NUM_ADDR   0X5C\\n#define INTERSECTION_LINE1_ANGLE_LOW_ADDR   0X5D\\n#define INTERSECTION_LINE1_ANGLE_HIGH_ADDR  0X5E\\n#define INTERSECTION_LINE2_ANGLE_LOW_ADDR   0X5F\\n#define INTERSECTION_LINE2_ANGLE_HIGH_ADDR  0X60\\n#define INTERSECTION_LINE3_ANGLE_LOW_ADDR   0X61\\n#define INTERSECTION_LINE3_ANGLE_HIGH_ADDR  0X62\\n#define INTERSECTION_LINE4_ANGLE_LOW_ADDR   0X63\\n#define INTERSECTION_LINE4_ANGLE_HIGH_ADDR  0X64\\n#define INTERSECTION_LINE5_ANGLE_LOW_ADDR   0X65\\n#define INTERSECTION_LINE5_ANGLE_HIGH_ADDR  0X66\\n#define INTERSECTION_LINE6_ANGLE_LOW_ADDR   0X67\\n#define INTERSECTION_LINE6_ANGLE_HIGH_ADDR  0X68\\n#define INTERSECTION_INDEX_LOW_ADDR   0X69\\n#define INTERSECTION_INDEX_HIGH_ADDR  0X6A\\n\\n#define BARCODE_NUM_ADDR        0X6F\\n#define BARCODE0_X_ADDR         0X70\\n#define BARCODE0_Y_ADDR         0X71\\n#define BARCODE1_X_ADDR         0X72\\n#define BARCODE1_Y_ADDR         0X73\\n#define BARCODE2_X_ADDR         0X74\\n#define BARCODE2_Y_ADDR         0X75\\n#define BARCODE3_X_ADDR         0X76\\n#define BARCODE3_Y_ADDR         0X77\\n#define BARCODE4_X_ADDR         0X78\\n#define BARCODE4_Y_ADDR         0X79\\n#define BARCODE5_X_ADDR         0X7A\\n#define BARCODE5_Y_ADDR         0X7B\\n#define BARCODE6_X_ADDR         0X7C\\n#define BARCODE6_Y_ADDR         0X7D\\n#define BARCODE7_X_ADDR         0X7E\\n#define BARCODE7_Y_ADDR         0X7F\\n#define BARCODE8_X_ADDR         0X80\\n#define BARCODE8_Y_ADDR         0X81\\n#define BARCODE9_X_ADDR         0X82\\n#define BARCODE9_Y_ADDR         0X83\\n#define BARCODE10_X_ADDR        0X84\\n#define BARCODE10_Y_ADDR        0X85\\n#define BARCODE11_X_ADDR        0X86\\n#define BARCODE11_Y_ADDR        0X87\\n#define BARCODE12_X_ADDR        0X88\\n#define BARCODE12_Y_ADDR        0X89\\n#define BARCODE13_X_ADDR        0X8A\\n#define BARCODE13_Y_ADDR        0X8B\\n#define BARCODE14_X_ADDR        0X8C\\n#define BARCODE14_Y_ADDR        0X8D\\n#define BARCODE15_X_ADDR        0X8E\\n#define BARCODE15_Y_ADDR        0X8F\\n\\n#define RGB_R_ADDR              0X90\\n#define RGB_G_ADDR              0X91\\n#define RGB_B_ADDR              0X92\\n#define RGB_SATURATION_ADDR     0X93\\n#define RGB_GRAY_ADDR           0X94\\n#define RGB_X_ADDR              0X95\\n#define RGB_Y_ADDR              0X97\\n\\n#define GET_KEY_STATE_ADDR      0X9A\\n#define GET_STUDY_STATE_ADDR    0X9B\\n\\n#define SET_LINE_FOLLOW_MODE    0XA0\\n#define SET_VECTOR_MODE         0XA1\\n#define SET_DEFAULT_TURN_ANGLE  0XA2\\n#define SET_NEXT_TURN_ANGLE     0XA4\\n#define SET_CAMERA_BRIGHNESS    0XA6\\n#define SET_RGB                 0XA7\\n#define SET_LED                 0XAA\\n#define SET_PIXY_MODE           0XAB\\n#define SET_START_STUDY         0XAC\\n#define SET_STUDY_TIME          0XAD\\n\\n/**\\n * Class: MeCamera\\n * \\\\par Description\\n * Declaration of Class MeCamera\\n */\\n#ifndef ME_PORT_DEFINED\\nclass MeCamera\\n#else // !ME_PORT_DEFINED\\nclass MeCamera : public MePort\\n#endif // !ME_PORT_DEFINED\\n{\\npublic:\\n#ifdef ME_PORT_DEFINED\\n\\n/**\\n * Alternate Constructor which can call your own function to map the MeCompass to arduino port\\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\\n * \\\\param[in]\\n *   port - RJ25 port from PORT_1 to PORT_4\\n */\\n  MeCamera(uint8_t port);\\n#else\\n/**\\n * Alternate Constructor which can call your own function to map the AD0 and INT to arduino port,\\n * no pins are used or initialized here\\n * \\\\param[in]\\n *   AD0 - arduino gpio number\\n * \\\\param[in]\\n *   INT - arduino gpio number\\n */\\n MeCamera(uint8_t AD0, uint8_t INT);\\n\\n#endif  //  ME_PORT_DEFINED\\n/**\\n * \\\\par Function\\n *   setpin\\n * \\\\par Description\\n *   Set the PIN of the button module.\\n * \\\\param[in]\\n *   AD0 - pin mapping for arduino\\n * \\\\param[in]\\n *   INT - pin mapping for arduino\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None.\\n * \\\\par Others\\n *   Set global variable _AD0, _INT, s1 and s2\\n */\\n  void setpin(uint8_t AD0, uint8_t INT);\\n\\n/**\\n * \\\\par Function\\n *   begin\\n * \\\\par Description\\n *   Initialize the MeCamera.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n *   None\\n */\\n  void begin();\\n\\n/**\\n * \\\\par Function\\n *   setCameraMode\\n * \\\\par Description\\n *   Set camera in mode: IDLE_MODE / CCC_MODE / LINE_MODE / VIDEO_MODE\\n *   Setting mode delay time 500ms ~ 1500ms.\\n *   mode: IDLE_MODE / CCC_MODE / LINE_MODE / VIDEO_MODE\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   0:  set sucess\\n *   -1: set fail\\n * \\\\par Others\\n */\\n  int8_t setCameraMode(uint8_t mode);\\n\\n/**\\n * \\\\par Function\\n *   setLineMode\\n * \\\\par Description\\n *   Set line follow mode\\n * \\\\param[in]\\n *   mode: \\n *   0 - find dark lines on a light background (black lines)\\n  *  1 - find light lines on a dark background (white lines)\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   0: set sucess\\n *   -1:set fail\\n * \\\\par Others\\n */\\n  int8_t setLineMode(uint8_t mode);\\n\\n/**\\n * \\\\par Function\\n *   setLED\\n * \\\\par Description\\n *   Set Supplementary lamp status\\n * \\\\param[in]\\n *   onOff: \\n *   0 - Turn off the supplementary light\\n  *  1 - Turn on the supplementary light\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   0: set sucess\\n *   -1:set fail\\n * \\\\par Others\\n */\\n  int8_t setLED(uint8_t onOff);\\n\\n/**\\n * \\\\par Function\\n *   startStudyCCC\\n * \\\\par Description\\n *   Start enter study CCC\\n * \\\\param[in]\\n *    sig - color signatures, numbered 1-7\\n *    times - study timeout ,unit 1s\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   0: study  sucess\\n *   -1:study  fail\\n * \\\\par Others\\n */\\n  int8_t startStudyCCC(uint8_t sig, uint8_t times);\\n\\n/**\\n * \\\\par Function\\n *   getCCCValue\\n * \\\\par Description\\n *   get CCC value\\n * \\\\param[in]\\n *   sig - color signatures, numbered 1-7\\n *   type - data type, CCC_X/CCC_Y/CCC_W/CCC_H\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the value of CCC:\\n *    - x-axis value ranges between 0 and 319\\n *    - y-axis value ranges between 0 and 239\\n *    - width value ranges between 0 and 320\\n *    - height value ranges between 0 and 240\\n * \\\\par Others\\n */\\n  uint16_t getCCCValue(uint8_t sig, uint8_t type);\\n\\n/**\\n * \\\\par Function\\n *   getVectorValue\\n * \\\\par Description\\n *   get the value of the Vector or line\\n * \\\\param[in]\\n *   type - data type, VECTOR_X0/VECTOR_Y0/VECTOR_X1/VECTOR_Y1\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the value of the vector:\\n *   - x0 value ranges between 0 and 319\\n *   - y0 value ranges between 0 and 239\\n *   - x1 value ranges between 0 and 319\\n *   - y1 value ranges between 0 and 239\\n * \\\\par Others\\n */\\n  uint16_t getVectorValue(uint8_t type);\\n\\n/**\\n * \\\\par Function\\n *   getIntersectionValue\\n * \\\\par Description\\n *   get the value of the intersection\\n * \\\\param[in]\\n *   type - data type, INTERSECTION_X/INTERSECTION_Y/INTERSECTION_NUM\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the value of the intersection:\\n *   - x-axis value ranges between 0 and 319\\n *   - y-axis value ranges between 0 and 239\\n *   - num the number of lines (branches), ranges between 0 and 6\\n * \\\\par Others\\n */\\n  uint16_t getIntersectionValue(uint8_t type);\\n\\n/**\\n * \\\\par Function\\n *   getIntersectionAngle\\n * \\\\par Description\\n *   get the angle in degrees of the line\\n * \\\\param[in]\\n *   index: the tracking index of the line, 1 ~ 6\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the angle in degrees of the line, The value ranges between -180 and 180\\n * \\\\par Others\\n */\\n  int16_t getIntersectionAngle(uint8_t index);\\n\\n/**\\n * \\\\par Function\\n *   getBarCodeValue\\n * \\\\par Description\\n *   get the value location of the barcode.\\n * \\\\param[in]\\n *   code - value of the code, The value ranges between 0 and 15\\n *   type - data type, BARCODE_X/BARCODE_Y\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   the value of the barcode:\\n *   - x-axis value ranges between 0 and 319\\n *   - y-axis value ranges between 0 and 239\\n * \\\\par Others\\n */\\n  uint16_t getBarCodeValue(uint8_t code, uint8_t type);\\n\\n/**\\n * \\\\par Function\\n *   setMotorDiffSpeedKp\\n * \\\\par Description\\n *   Set left/right Motor differential speed sensitivity\\n * \\\\param[in]\\n *   kp: 0 ~ 1\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n */\\n  void setMotorDiffSpeedKp(float _kp);\\n\\n/**\\n * \\\\par Function\\n *   getFollowColorValue\\n * \\\\par Description\\n *   When automatically following the color block: Get left/right Motor differential speed value\\n * \\\\param[in]\\n *    sig - color signatures, numbered 1-7\\n *   x - x axis location in the image, 0 ~ 319, -1 invalid\\n *   y - y axis location in the image, 0 ~ 239, -1 invalid\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Motor differential speed value: -100 ~ 100\\n * \\\\par Others\\n */\\n  int16_t getFollowColorValue(uint8_t sig, int16_t x, int16_t y);\\n\\n/**\\n * \\\\par Function\\n *   getFollowBarcodeValue\\n * \\\\par Description\\n *   When automatically following the barcode: Get left/right Motor differential speed value\\n * \\\\param[in]\\n *   code - value of the barcode, The value ranges between 0 and 15\\n *   x - x axis location in the image, 0 ~ 319, -1 invalid\\n *   y - y axis location in the image, 0 ~ 239, -1 invalid\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Motor differential speed value: -100 ~ 100\\n * \\\\par Others\\n */\\n  int16_t getFollowBarcodeValue(uint8_t code, int16_t x, int16_t y);\\n\\n/**\\n * \\\\par Function\\n *   getFollowVectorValue\\n * \\\\par Description\\n *   When automatically following the vector: Get left/right Motor differential speed value\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Motor differential speed value: -100 ~ 100\\n * \\\\par Others\\n */\\n  int16_t getFollowVectorValue(void);\\n\\n/**\\n * \\\\par Function\\n *   isLockedCCC\\n * \\\\par Description\\n *   is locked the color block?\\n * \\\\param[in]\\n *   sig - color signatures, numbered 1-7\\n *   x - x axis location in the image, 0 ~ 319, -1 invalid\\n *   y - y axis location in the image, 0 ~ 239, -1 invalid\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   true - Lock the target position\\n *   false - No Lock the target position\\n * \\\\par Others\\n */\\n  bool isLockedCCC(uint8_t sig, int16_t x, int16_t y);\\n\\n/**\\n * \\\\par Function\\n *   isLockedBarcode\\n * \\\\par Description\\n *   is locked the Barcode?\\n * \\\\param[in]\\n *   code - value of the barcode, The value ranges between 0 and 15\\n *   x - x axis location in the image, 0 ~ 319, -1 invalid\\n *   y - y axis location in the image, 0 ~ 239, -1 invalid\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   true - Lock the target position\\n *   false - No Lock the target position\\n * \\\\par Others\\n */\\n  bool isLockedBarcode(uint8_t code, int16_t x, int16_t y);\\n\\nprivate:\\n  uint8_t i2cData[8];\\n  uint8_t Device_Address;\\n  uint8_t pixy_work_mode;\\n  int16_t motor_diff_speed;\\n  uint8_t led_change_flag;\\n  float kp;\\n  \\n/**\\n * \\\\par Function\\n *   writeReg\\n * \\\\par Description\\n *   Write the registor of i2c device.\\n * \\\\param[in]\\n *   reg - the address of registor.\\n * \\\\param[in]\\n *   data - the data that will be written to the registor.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   To set the registor for initializing.\\n */\\n  int8_t writeReg(uint8_t reg, uint8_t data);\\n\\n/**\\n * \\\\par Function\\n *   readData\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to read data.\\n */\\n  int8_t readData(uint8_t start, uint8_t *buffer, uint8_t size);\\n\\n/**\\n * \\\\par Function\\n *   readPixy2Data\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to read data.\\n */\\n  int8_t readPixy2Data(uint8_t start, uint8_t *buffer, uint8_t size);\\n\\n\\n/**\\n * \\\\par Function\\n *   writeData\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to write data.\\n */\\n  int8_t writeData(uint8_t start, const uint8_t *pData, uint8_t size);\\n};\\n#endif //  MeCamera_H\\n\" }"
];