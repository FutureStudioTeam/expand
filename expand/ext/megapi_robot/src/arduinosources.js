export default [
    "{ filename: \"src/MeBarrierSensor.cpp\", code: \"/**\\r\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\r\\n * \\\\class MeBarrierSensor\\r\\n * \\\\brief   Driver for Me line follwer device.\\r\\n * @file    MeBarrierSensor.cpp\\r\\n * @author  MakeBlock\\r\\n * @version V1.0.0\\r\\n * @date    2021/03/24\\r\\n * @brief   Driver for Me line follwer device.\\r\\n *\\r\\n * \\\\par Copyright\\r\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\r\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\r\\n *\\r\\n * \\\\par Open Source Licensing GPL V2\\r\\n * This is the appropriate option if you want to share the source code of your \\\\n\\r\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\r\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\r\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\r\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\r\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\r\\n *\\r\\n * \\\\par Description\\r\\n * This file is a drive for Me line follwer device, It supports line follwer device\\r\\n * V2.2 provided by the MakeBlock. The line follwer used Infrared Tube to Use infrared\\r\\n * receiver and transmitter to detect the black line.\\r\\n *\\r\\n * \\\\par Method List:\\r\\n *\\r\\n *    1. void MeBarrierSensor::setpin(uint8_t SensorPin)\\r\\n *    2. uint8_t MeBarrierSensor::readSensor(void)\\r\\n *    3. bool MeBarrierSensor::isBarried(void)\\r\\n *\\r\\n * \\\\par History:\\r\\n * <pre>\\r\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\r\\n * huyisi         2021/03/24     1.0.0            build the new.\\r\\n * </pre>\\r\\n *\\r\\n * @example LineFollowerTest.ino\\r\\n */\\r\\n\\r\\n#include \\\"MeBarrierSensor.h\\\"\\r\\n\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the line follwer device available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   SensorPin - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nMeBarrierSensor::MeBarrierSensor(uint8_t SensorPin)\\r\\n{\\r\\n  _SensorPin = SensorPin;\\r\\n  pinMode(_SensorPin,INPUT);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the line follwer device available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   SensorPin - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nvoid MeBarrierSensor::setpin(uint8_t SensorPin)\\r\\n{\\r\\n  _SensorPin = SensorPin;\\r\\n  pinMode(_SensorPin,INPUT);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   readSensor1\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   0: sensor1 is Barried \\\\n\\r\\n *   1: sensor1 is not Barried \\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nbool MeBarrierSensor::readSensor(void)\\r\\n{\\r\\n  return digitalRead(_SensorPin);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   onLine\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   true: sensor is Barried \\\\n\\r\\n *   false: sensor is not Barried\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nbool MeBarrierSensor::isBarried(void)\\r\\n{\\r\\n  if(digitalRead(_SensorPin))\\r\\n  {\\r\\n    return false;\\r\\n  }\\r\\n  else\\r\\n  {\\r\\n    return true;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\" }",
    "{ filename: \"src/MeBarrierSensor.h\", code: \"/**\\r\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\r\\n * \\\\class   MeBarrierSensor\\r\\n * \\\\brief   Driver for MeBarrierSensor module.\\r\\n * @file    MeBarrierSensor.h\\r\\n * @author  MakeBlock\\r\\n * @version V1.0.0\\r\\n * @date    2021/03/24\\r\\n * @brief   Header for MeBarrierSensor.cpp.\\r\\n *\\r\\n * \\\\par Copyright\\r\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\r\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\r\\n *\\r\\n * \\\\par Open Source Licensing GPL V2\\r\\n * This is the appropriate option if you want to share the source code of your \\\\n\\r\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\r\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\r\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\r\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\r\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\r\\n *\\r\\n * \\\\par Description\\r\\n *\\r\\n * \\\\par Method List:\\r\\n *\\r\\n *    1. void MeBarrierSensor::setpin(uint8_t SensorPin)\\r\\n *    2. uint8_t MeBarrierSensor::readSensor(void)\\r\\n *    3. bool MeBarrierSensor::isBarried(void)\\r\\n *\\r\\n * \\\\par History:\\r\\n * <pre>\\r\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\r\\n * huyisi         2021/03/24     1.0.0            build the new.\\r\\n * </pre>\\r\\n *\\r\\n */\\r\\n\\r\\n/* Define to prevent recursive inclusion -------------------------------------*/\\r\\n#ifndef MeBarrierSensor_H\\r\\n#define MeBarrierSensor_H\\r\\n\\r\\n/* Includes ------------------------------------------------------------------*/\\r\\n#include <stdint.h>\\r\\n#include <stdbool.h>\\r\\n#include <Arduino.h>\\r\\n#include \\\"MeConfig.h\\\"\\r\\n\\r\\n#ifdef ME_PORT_DEFINED\\r\\n#include \\\"MePort.h\\\"\\r\\n#endif // ME_PORT_DEFINED\\r\\n\\r\\n/* Exported classes ----------------------------------------------------------*/\\r\\n/**\\r\\n * Class: MeBarrierSensor\\r\\n * \\\\par Description\\r\\n * Declaration of Class MeBarrierSensor.\\r\\n */\\r\\n#ifndef ME_PORT_DEFINED\\r\\nclass MeBarrierSensor\\r\\n#else // !ME_PORT_DEFINED\\r\\nclass MeBarrierSensor : public MePort\\r\\n#endif  // !ME_PORT_DEFINED\\r\\n{\\r\\npublic:\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the line follwer device available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   SensorPin - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n MeBarrierSensor(uint8_t SensorPin);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *    setpin\\r\\n * \\\\par Description\\r\\n *    Reset the limit switch available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *    switchPin - arduino port for switch detect pin.\\r\\n * \\\\par Output\\r\\n *    None\\r\\n * \\\\par Return\\r\\n *    None\\r\\n * \\\\par Others\\r\\n *    None\\r\\n */\\r\\n  void setpin(uint8_t switchPin);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   readSensor1\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   0: sensor1 is Barried \\\\n\\r\\n *   1: sensor1 is not Barried \\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n  bool readSensor(void);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   onLine\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   true: sensor is Barried \\\\n\\r\\n *   false: sensor is not Barried\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n bool isBarried(void);\\r\\n\\r\\nprivate:\\r\\n  uint8_t _SensorPin;\\r\\n};\\r\\n#endif\\r\\n\" }",
    "{ filename: \"src/MeCollisionSensor.cpp\", code: \"/**\\r\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\r\\n * \\\\class MeCollisionSensor\\r\\n * \\\\brief   Driver for Me line follwer device.\\r\\n * @file    MeCollisionSensor.cpp\\r\\n * @author  MakeBlock\\r\\n * @version V1.0.0\\r\\n * @date    2021/03/24\\r\\n * @brief   Driver for Me line follwer device.\\r\\n *\\r\\n * \\\\par Copyright\\r\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\r\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\r\\n *\\r\\n * \\\\par Open Source Licensing GPL V2\\r\\n * This is the appropriate option if you want to share the source code of your \\\\n\\r\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\r\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\r\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\r\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\r\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\r\\n *\\r\\n * \\\\par Description\\r\\n * This file is a drive for Me line follwer device, It supports line follwer device\\r\\n * V2.2 provided by the MakeBlock. The line follwer used Infrared Tube to Use infrared\\r\\n * receiver and transmitter to detect the black line.\\r\\n *\\r\\n * \\\\par Method List:\\r\\n *\\r\\n *    1. void MeCollisionSensor::setpin(uint8_t SensorPin)\\r\\n *    2. uint8_t MeCollisionSensor::readSensor(void)\\r\\n *    3. bool MeCollisionSensor::isCollision(void)\\r\\n *\\r\\n * \\\\par History:\\r\\n * <pre>\\r\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\r\\n * huyisi         2021/03/24     1.0.0            build the new.\\r\\n * </pre>\\r\\n *\\r\\n * @example LineFollowerTest.ino\\r\\n */\\r\\n\\r\\n#include \\\"MeCollisionSensor.h\\\"\\r\\n\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the line follwer device available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   SensorPin - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nMeCollisionSensor::MeCollisionSensor(uint8_t SensorPin)\\r\\n{\\r\\n  _SensorPin = SensorPin;\\r\\n  pinMode(_SensorPin,INPUT);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the line follwer device available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   SensorPin - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nvoid MeCollisionSensor::setpin(uint8_t SensorPin)\\r\\n{\\r\\n  _SensorPin = SensorPin;\\r\\n  pinMode(_SensorPin,INPUT);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   readSensor1\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   0: sensor is Collision \\\\n\\r\\n *   1: sensor is not Collision\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nbool MeCollisionSensor::readSensor(void)\\r\\n{\\r\\n  return digitalRead(_SensorPin);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   onLine\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   true: sensor is Collision \\\\n\\r\\n *   false: sensor is not Collision\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nbool MeCollisionSensor::isCollision(void)\\r\\n{\\r\\n  if(digitalRead(_SensorPin))\\r\\n  {\\r\\n    return false;\\r\\n  }\\r\\n  else\\r\\n  {\\r\\n    return true;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\" }",
    "{ filename: \"src/MeCollisionSensor.h\", code: \"/**\\r\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\r\\n * \\\\class   MeCollisionSensor\\r\\n * \\\\brief   Driver for MeCollisionSensor module.\\r\\n * @file    MeCollisionSensor.h\\r\\n * @author  MakeBlock\\r\\n * @version V1.0.0\\r\\n * @date    2021/03/24\\r\\n * @brief   Header for MeCollisionSensor.cpp.\\r\\n *\\r\\n * \\\\par Copyright\\r\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\r\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\r\\n *\\r\\n * \\\\par Open Source Licensing GPL V2\\r\\n * This is the appropriate option if you want to share the source code of your \\\\n\\r\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\r\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\r\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\r\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\r\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\r\\n *\\r\\n * \\\\par Description\\r\\n *\\r\\n * \\\\par Method List:\\r\\n *\\r\\n *    1. void MeCollisionSensor::setpin(uint8_t SensorPin)\\r\\n *    2. uint8_t MeCollisionSensor::readSensor(void)\\r\\n *    3. bool MeCollisionSensor::isCollision(void)\\r\\n *\\r\\n * \\\\par History:\\r\\n * <pre>\\r\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\r\\n * huyisi         2021/03/24     1.0.0            build the new.\\r\\n * </pre>\\r\\n *\\r\\n */\\r\\n\\r\\n/* Define to prevent recursive inclusion -------------------------------------*/\\r\\n#ifndef MeCollisionSensor_H\\r\\n#define MeCollisionSensor_H\\r\\n\\r\\n/* Includes ------------------------------------------------------------------*/\\r\\n#include <stdint.h>\\r\\n#include <stdbool.h>\\r\\n#include <Arduino.h>\\r\\n#include \\\"MeConfig.h\\\"\\r\\n\\r\\n#ifdef ME_PORT_DEFINED\\r\\n#include \\\"MePort.h\\\"\\r\\n#endif // ME_PORT_DEFINED\\r\\n\\r\\n/* Exported classes ----------------------------------------------------------*/\\r\\n/**\\r\\n * Class: MeCollisionSensor\\r\\n * \\\\par Description\\r\\n * Declaration of Class MeCollisionSensor.\\r\\n */\\r\\n#ifndef ME_PORT_DEFINED\\r\\nclass MeCollisionSensor\\r\\n#else // !ME_PORT_DEFINED\\r\\nclass MeCollisionSensor : public MePort\\r\\n#endif  // !ME_PORT_DEFINED\\r\\n{\\r\\npublic:\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the line follwer device available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   SensorPin - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n MeCollisionSensor(uint8_t SensorPin);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *    setpin\\r\\n * \\\\par Description\\r\\n *    Reset the limit switch available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *    switchPin - arduino port for switch detect pin.\\r\\n * \\\\par Output\\r\\n *    None\\r\\n * \\\\par Return\\r\\n *    None\\r\\n * \\\\par Others\\r\\n *    None\\r\\n */\\r\\n  void setpin(uint8_t switchPin);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   readSensor1\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   0: sensor is Collision \\\\n\\r\\n *   1: sensor is not Collision\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n  bool readSensor(void);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   onLine\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   true: sensor is Collision \\\\n\\r\\n *   false: sensor is not Collision\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n bool isCollision(void);\\r\\n\\r\\nprivate:\\r\\n  uint8_t _SensorPin;\\r\\n};\\r\\n#endif\\r\\n\" }",
    "{ filename: \"src/MeSingleLineFollower.cpp\", code: \"/**\\r\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\r\\n * \\\\class MeSingleLineFollower\\r\\n * \\\\brief   Driver for Me line follwer device.\\r\\n * @file    MeSingleLineFollower.cpp\\r\\n * @author  MakeBlock\\r\\n * @version V1.0.0\\r\\n * @date    2021/03/24\\r\\n * @brief   Driver for Me line follwer device.\\r\\n *\\r\\n * \\\\par Copyright\\r\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\r\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\r\\n *\\r\\n * \\\\par Open Source Licensing GPL V2\\r\\n * This is the appropriate option if you want to share the source code of your \\\\n\\r\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\r\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\r\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\r\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\r\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\r\\n *\\r\\n * \\\\par Description\\r\\n * This file is a drive for Me line follwer device, It supports line follwer device\\r\\n * V2.2 provided by the MakeBlock. The line follwer used Infrared Tube to Use infrared\\r\\n * receiver and transmitter to detect the black line.\\r\\n *\\r\\n * \\\\par Method List:\\r\\n *\\r\\n *    1. void MeSingleLineFollower::setpin(uint8_t SensorPin)\\r\\n *    2. uint8_t MeSingleLineFollower::readSensor(void)\\r\\n *    3. bool MeSingleLineFollower::onLine(void)\\r\\n *    4. bool MeSingleLineFollower::onBackground(void)\\r\\n *\\r\\n * \\\\par History:\\r\\n * <pre>\\r\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\r\\n * huyisi            2021/03/24         1.0.0            build the new.\\r\\n * </pre>\\r\\n *\\r\\n * @example LineFollowerTest.ino\\r\\n */\\r\\n\\r\\n#include \\\"MeSingleLineFollower.h\\\"\\r\\n\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the line follwer device available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   SensorPin - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nMeSingleLineFollower::MeSingleLineFollower(uint8_t SensorPin)\\r\\n{\\r\\n  _SensorPin = SensorPin;\\r\\n  pinMode(_SensorPin,INPUT);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the line follwer device available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   SensorPin - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nvoid MeSingleLineFollower::setpin(uint8_t SensorPin)\\r\\n{\\r\\n  _SensorPin = SensorPin;\\r\\n  pinMode(_SensorPin,INPUT);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   readSensor1\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   0: sensor1 is outside of black line \\\\n\\r\\n *   1: sensor1 is inside of black line\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nbool MeSingleLineFollower::readSensor(void)\\r\\n{\\r\\n  return digitalRead(_SensorPin);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   onLine\\r\\n * \\\\par Description\\r\\n *   Get the sensors1(left sensors) state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   true: sensor1 is on black line \\\\n\\r\\n *   false: sensor1 is outside of black line\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nbool MeSingleLineFollower::onLine(void)\\r\\n{\\r\\n  if(digitalRead(_SensorPin))\\r\\n  {\\r\\n    return false;\\r\\n  }\\r\\n  else\\r\\n  {\\r\\n    return true;\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   onBackground\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   true: sensor1 is inside of background \\\\n\\r\\n *   false: sensor1 is outside of background\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nbool MeSingleLineFollower::onBackground(void)\\r\\n{\\r\\n  if(digitalRead(_SensorPin))\\r\\n  {\\r\\n    return true;\\r\\n  }\\r\\n  else\\r\\n  {\\r\\n    return false;\\r\\n  }\\r\\n}\\r\\n\\r\\n\" }",
    "{ filename: \"src/MeSingleLineFollower.h\", code: \"/**\\r\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\r\\n * \\\\class   MeSingleLineFollower\\r\\n * \\\\brief   Driver for MeSingleLineFollower module.\\r\\n * @file    MeSingleLineFollower.h\\r\\n * @author  MakeBlock\\r\\n * @version V1.0.0\\r\\n * @date    2021/03/24\\r\\n * @brief   Header for MeSingleLineFollower.cpp.\\r\\n *\\r\\n * \\\\par Copyright\\r\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\r\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\r\\n *\\r\\n * \\\\par Open Source Licensing GPL V2\\r\\n * This is the appropriate option if you want to share the source code of your \\\\n\\r\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\r\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\r\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\r\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\r\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\r\\n *\\r\\n * \\\\par Description\\r\\n *\\r\\n * \\\\par Method List:\\r\\n *\\r\\n *    1. void MeSingleLineFollower::setpin(uint8_t SensorPin)\\r\\n *    2. uint8_t MeSingleLineFollower::readSensor(void)\\r\\n *    3. bool MeSingleLineFollower::onLine(void)\\r\\n *    4. bool MeSingleLineFollower::onBackground(void)\\r\\n *\\r\\n * \\\\par History:\\r\\n * <pre>\\r\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\r\\n * huyisi         2021/03/24     1.0.0            build the new.\\r\\n * </pre>\\r\\n *\\r\\n */\\r\\n\\r\\n/* Define to prevent recursive inclusion -------------------------------------*/\\r\\n#ifndef MeSingleLineFollower_H\\r\\n#define MeSingleLineFollower_H\\r\\n\\r\\n/* Includes ------------------------------------------------------------------*/\\r\\n#include <stdint.h>\\r\\n#include <stdbool.h>\\r\\n#include <Arduino.h>\\r\\n#include \\\"MeConfig.h\\\"\\r\\n\\r\\n#ifdef ME_PORT_DEFINED\\r\\n#include \\\"MePort.h\\\"\\r\\n#endif // ME_PORT_DEFINED\\r\\n\\r\\n\\r\\n/* Exported classes ----------------------------------------------------------*/\\r\\n/**\\r\\n * Class: MeSingleLineFollower\\r\\n * \\\\par Description\\r\\n * Declaration of Class MeSingleLineFollower.\\r\\n */\\r\\n#ifndef ME_PORT_DEFINED\\r\\nclass MeSingleLineFollower\\r\\n#else // !ME_PORT_DEFINED\\r\\nclass MeSingleLineFollower : public MePort\\r\\n#endif  // !ME_PORT_DEFINED\\r\\n{\\r\\npublic:\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the line follwer device available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   SensorPin - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n MeSingleLineFollower(uint8_t SensorPin);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *    setpin\\r\\n * \\\\par Description\\r\\n *    Reset the limit switch available PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *    switchPin - arduino port for switch detect pin.\\r\\n * \\\\par Output\\r\\n *    None\\r\\n * \\\\par Return\\r\\n *    None\\r\\n * \\\\par Others\\r\\n *    None\\r\\n */\\r\\n  void setpin(uint8_t switchPin);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   readSensor1\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   0: sensor1 is outside of black line \\\\n\\r\\n *   1: sensor1 is inside of black line\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n  bool readSensor(void);\\r\\n\\r\\n /**\\r\\n * \\\\par Function\\r\\n *   onLine\\r\\n * \\\\par Description\\r\\n *   Get the sensors1(left sensors) state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   true: sensor1 is on black line \\\\n\\r\\n *   false: sensor1 is outside of black line\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n  bool onLine(void);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   onBackground\\r\\n * \\\\par Description\\r\\n *   Get the sensors state.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   true: sensor1 is inside of background \\\\n\\r\\n *   false: sensor1 is outside of background\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n bool onBackground(void);\\r\\n\\r\\nprivate:\\r\\n  uint8_t _SensorPin;\\r\\n};\\r\\n#endif\\r\\n\" }",
    "{ filename: \"src/MeNewRGBLed.cpp\", code: \"/**\\r\\n * \\\\par Copyright (C), 2014-2018, MakeBlock\\r\\n * \\\\class MeRGBLed\\r\\n * \\\\brief   Driver for W2812 full-color LED.\\r\\n * @file    MeRGBLed.cpp\\r\\n * @author  MakeBlock\\r\\n * @version V1.0.2\\r\\n * @date    2017/06/23\\r\\n * @brief   Driver for W2812 full-color LED lights\\r\\n *\\r\\n * \\\\par Copyright\\r\\n * This software is Copyright (C), 2014-2018, MakeBlock. Use is subject to license \\\\n\\r\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\r\\n *\\r\\n * \\\\par Open Source Licensing GPL V2\\r\\n * This is the appropriate option if you want to share the source code of your \\\\n\\r\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\r\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\r\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\r\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\r\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\r\\n *\\r\\n * \\\\par Description\\r\\n * This file is a drive for WS2811/2812 full-color LED lights, It supports\\r\\n * W2812B full-color LED lights device provided by the MakeBlock.\\r\\n *\\r\\n * \\\\par Method List:\\r\\n *\\r\\n *    1. void MeRGBLed::reset(uint8_t port)\\r\\n *    2. void MeRGBLed::reset(uint8_t port,uint8_t slot)\\r\\n *    3. void MeRGBLed::setpin(uint8_t port)\\r\\n *    4. uint8_t MeRGBLed::getNumber()\\r\\n *    5. cRGB MeRGBLed::getColorAt(uint8_t index)\\r\\n *    6. void MeRGBLed::fillPixelsBak(uint8_t red, uint8_t green, uint8_t blue)\\r\\n *    7. bool MeRGBLed::setColorAt(uint8_t index, uint8_t red, uint8_t green, uint8_t blue)\\r\\n *    8. bool MeRGBLed::setColor(uint8_t index, uint8_t red, uint8_t green, uint8_t blue)\\r\\n *    9. bool MeRGBLed::setColor(uint8_t red, uint8_t green, uint8_t blue)\\r\\n *    10. bool MeRGBLed::setColor(uint8_t index, long value)\\r\\n *    11. void MeRGBLed::show()\\r\\n *\\r\\n * \\\\par History:\\r\\n * <pre>\\r\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\r\\n * Mark Yan         2015/09/01     1.0.0            Rebuild the old lib.\\r\\n * Scott            2016/09/20     1.0.1            Add a delay.\\r\\n * Mark Yan         2017/06/23     1.0.2            Add function fillPixelsBak.\\r\\n * </pre>\\r\\n *\\r\\n * @example ColorLoopTest.ino\\r\\n * @example IndicatorsTest.ino\\r\\n * @example WhiteBreathLightTest.ino\\r\\n *\\r\\n * DERIVED FROM\\r\\n * light weight WS2812 lib V2.1 - Arduino support\\r\\n *\\r\\n * Controls WS2811/WS2812/WS2812B RGB-LEDs\\r\\n * Author: Tim (cpldcpu@gmail.com)\\r\\n *\\r\\n * Jan  18th, 2014  v2.0b Initial Version\\r\\n * March 7th, 2014  v2.1  Added option to retarget the port register during runtime\\r\\n *                        Removes inlining to allow compiling with c++\\r\\n *\\r\\n * License: GNU GPL v2 (see License.txt)\\r\\n */\\r\\n#include \\\"MeNewRGBLed.h\\\"\\r\\n\\r\\n/**\\r\\n * Alternate Constructor which can call your own function to map the MeRGBLed to arduino port,\\r\\n * it will assigned the LED display buffer and initialization the GPIO of LED lights. You can\\r\\n * set any arduino digital pin for the LED data PIN, The default number of light strips is 32.\\r\\n * \\\\param[in]\\r\\n *   port - arduino port\\r\\n */\\r\\nMeNewRGBLed::MeNewRGBLed(uint8_t port)\\r\\n{\\r\\n  pinMask       = digitalPinToBitMask(port);\\r\\n  ws2812_port   = portOutputRegister(digitalPinToPort(port) );\\r\\n  // set pinMode OUTPUT */\\r\\n  pinMode(port, OUTPUT);\\r\\n  setNumber(DEFAULT_MAX_LED_NUMBER);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Alternate Constructor which can call your own function to map the MeRGBLed to arduino port,\\r\\n * it will assigned the LED display buffer and initialization the GPIO of LED lights. You can\\r\\n * set any arduino digital pin for the LED data PIN, and reset the LED number by this constructor.\\r\\n * \\\\param[in]\\r\\n *   port - arduino port\\r\\n * \\\\param[in]\\r\\n *   led_num - The LED number\\r\\n */\\r\\nMeNewRGBLed::MeNewRGBLed(uint8_t port, uint8_t led_num)\\r\\n{\\r\\n  pinMask       = digitalPinToBitMask(port);\\r\\n  ws2812_port   = portOutputRegister(digitalPinToPort(port) );\\r\\n  // set pinMode OUTPUT */\\r\\n  pinMode(port, OUTPUT);\\r\\n  setNumber(led_num);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the LED available data PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   port - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nvoid MeNewRGBLed::setpin(uint8_t port)\\r\\n{\\r\\n  setColor(0,0,0,0);\\r\\n  fillPixelsBak(0,2,1);\\r\\n  pinMask   = digitalPinToBitMask(port);\\r\\n  ws2812_port = portOutputRegister(digitalPinToPort(port) );\\r\\n  pinMode(port, OUTPUT);\\r\\n // _port = 0;\\r\\n // _slot = SLOT2;\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setNumber\\r\\n * \\\\par Description\\r\\n *   Assigned the LED display buffer by the LED number\\r\\n * \\\\param[in]\\r\\n *   num_leds - The LED number you used\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nvoid MeNewRGBLed::setNumber(uint8_t num_leds)\\r\\n{\\r\\n  count_led = num_leds;\\r\\n  pixels    = (uint8_t*)malloc(count_led * 3);\\r\\n  if(!pixels)\\r\\n  {\\r\\n    printf(\\\"There is not enough space!\\\\r\\\\n\\\");\\r\\n  }\\r\\n  for(int16_t i = 0; i < count_led * 3; i++)\\r\\n  {\\r\\n    pixels[i] = 0;\\r\\n  }\\r\\n\\r\\n  pixels_bak    = (uint8_t*)malloc(count_led * 3);\\r\\n  if(!pixels_bak)\\r\\n  {\\r\\n    printf(\\\"There is not enough space!\\\\r\\\\n\\\");\\r\\n  }\\r\\n  for(int16_t i = 0; i < count_led * 3; i++)\\r\\n  {\\r\\n    pixels_bak[i] = 0;\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   getColorAt\\r\\n * \\\\par Description\\r\\n *   Get the LED color value from its index\\r\\n * \\\\param[in]\\r\\n *   index - The LED index number you want to read its value\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   The LED color value, include the R,G,B\\r\\n * \\\\par Others\\r\\n *   The index value from 1 to the max\\r\\n */\\r\\ncNewRGB MeNewRGBLed::getColorAt(uint8_t index)\\r\\n{\\r\\n  cNewRGB px_value;\\r\\n\\r\\n  if(index < count_led)\\r\\n  {\\r\\n    uint8_t tmp;\\r\\n    tmp = (index-1) * 3;\\r\\n\\r\\n    px_value.g = pixels[tmp];\\r\\n    px_value.r = pixels[tmp + 1];\\r\\n    px_value.b = pixels[tmp + 2];\\r\\n  }\\r\\n  return(px_value);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   getNumber\\r\\n * \\\\par Description\\r\\n *   Get the LED number you can light it.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   The total number of LED's\\r\\n * \\\\par Others\\r\\n *   The index value from 1 to the max\\r\\n */\\r\\nuint8_t MeNewRGBLed::getNumber(void)\\r\\n{\\r\\n  return(count_led);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   fillPixelsBak\\r\\n * \\\\par Description\\r\\n *   fill the LED color data to pixels_bak.\\r\\n * \\\\param[in]\\r\\n *   red - Red values\\r\\n * \\\\param[in]\\r\\n *   green - green values\\r\\n * \\\\param[in]\\r\\n *   blue - blue values\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nvoid MeNewRGBLed::fillPixelsBak(uint8_t red, uint8_t green, uint8_t blue)\\r\\n{\\r\\n  for(int16_t i = 0; i < count_led; i++)\\r\\n  {\\r\\n    uint8_t tmp = i * 3;\\r\\n    pixels_bak[tmp] = green;\\r\\n    pixels_bak[tmp + 1] = red;\\r\\n    pixels_bak[tmp + 2] = blue;\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setColorAt\\r\\n * \\\\par Description\\r\\n *   Set the LED color for any LED.\\r\\n * \\\\param[in]\\r\\n *   index - The LED index number you want to set its color\\r\\n * \\\\param[in]\\r\\n *   red - Red values\\r\\n * \\\\param[in]\\r\\n *   green - green values\\r\\n * \\\\param[in]\\r\\n *   blue - blue values\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   The index value from 0 to the max.\\r\\n */\\r\\nbool MeNewRGBLed::setColorAt(uint8_t index, uint8_t red, uint8_t green, uint8_t blue)\\r\\n{\\r\\n  if(index < count_led)\\r\\n  {\\r\\n    uint8_t tmp = index * 3;\\r\\n    pixels[tmp] = green;\\r\\n    pixels[tmp + 1] = red;\\r\\n    pixels[tmp + 2] = blue;\\r\\n    return(true);\\r\\n  }\\r\\n  return(false);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setColor\\r\\n * \\\\par Description\\r\\n *   Set the LED color for any LED.\\r\\n * \\\\param[in]\\r\\n *   index - The LED index number you want to set its color\\r\\n * \\\\param[in]\\r\\n *   red - Red values\\r\\n * \\\\param[in]\\r\\n *   green - green values\\r\\n * \\\\param[in]\\r\\n *   blue - blue values\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   The index value from 1 to the max, if you set the index 0, all the LED will be lit\\r\\n */\\r\\nbool MeNewRGBLed::setColor(uint8_t index, uint8_t red, uint8_t green, uint8_t blue)\\r\\n{\\r\\n  if(index == 0)\\r\\n  {\\r\\n    for(int16_t i = 0; i < count_led; i++)\\r\\n    {\\r\\n      setColorAt(i,red,green,blue);\\r\\n    }\\r\\n    return(true);\\r\\n  }\\r\\n  else\\r\\n  {\\r\\n    setColorAt(index-1,red,green,blue);\\r\\n  }\\r\\n  return(false);\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setColor\\r\\n * \\\\par Description\\r\\n *   Set the LED color for all LED.\\r\\n * \\\\param[in]\\r\\n *   red - Red values\\r\\n * \\\\param[in]\\r\\n *   green - green values\\r\\n * \\\\param[in]\\r\\n *   blue - blue values\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   All the LED will be lit.\\r\\n */\\r\\nbool MeNewRGBLed::setColor(uint8_t red, uint8_t green, uint8_t blue)\\r\\n{\\r\\n  return(setColor(0, red, green, blue) );;\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setColor\\r\\n * \\\\par Description\\r\\n *   Set the LED color for any LED.\\r\\n * \\\\param[in]\\r\\n *   value - the LED color defined as long type, for example (white) = 0xFFFFFF\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   The index value from 1 to the max, if you set the index 0, all the LED will be lit\\r\\n */\\r\\nbool MeNewRGBLed::setColor(uint8_t index, long value)\\r\\n{\\r\\n  if(index == 0)\\r\\n  {\\r\\n    for(int16_t i = 0; i < count_led; i++)\\r\\n    {\\r\\n      uint8_t tmp    = index * 3;\\r\\n      uint8_t red    = (value & 0xff0000) >> 16;\\r\\n      uint8_t green  = (value & 0xff00) >> 8;\\r\\n      uint8_t blue   = value & 0xff;\\r\\n      pixels[tmp]    = green;\\r\\n      pixels[tmp + 1] = red;\\r\\n      pixels[tmp + 2] = blue;\\r\\n    }\\r\\n    return(true);\\r\\n  }\\r\\n  else if(index < count_led)\\r\\n  {\\r\\n    uint8_t tmp    = (index - 1) * 3;\\r\\n    uint8_t red    = (value & 0xff0000) >> 16;\\r\\n    uint8_t green  = (value & 0xff00) >> 8;\\r\\n    uint8_t blue   = value & 0xff;\\r\\n    pixels[tmp]    = green;\\r\\n    pixels[tmp + 1] = red;\\r\\n    pixels[tmp + 2] = blue;\\r\\n    return(true);\\r\\n  }\\r\\n  return(false);\\r\\n}\\r\\n\\r\\n/*\\r\\n  This routine writes an array of bytes with RGB values to the Dataout pin\\r\\n  using the fast 800kHz clockless WS2811/2812 protocol.\\r\\n */\\r\\n/* Timing in ns */\\r\\n#define w_zeropulse (350)\\r\\n#define w_onepulse  (900)\\r\\n#define w_totalperiod (1250)\\r\\n\\r\\n/* Fixed cycles used by the inner loop */\\r\\n#define w_fixedlow  (3)\\r\\n#define w_fixedhigh (6)\\r\\n#define w_fixedtotal (10)\\r\\n\\r\\n/* Insert NOPs to match the timing, if possible */\\r\\n#define w_zerocycles ( ( (F_CPU / 1000) * w_zeropulse) / 1000000)\\r\\n#define w_onecycles ( ( (F_CPU / 1000) * w_onepulse + 500000) / 1000000)\\r\\n#define w_totalcycles ( ( (F_CPU / 1000) * w_totalperiod + 500000) / 1000000)\\r\\n\\r\\n/* w1 - nops between rising edge and falling edge - low */\\r\\n#define w1 (w_zerocycles - w_fixedlow)\\r\\n/* w2   nops between fe low and fe high */\\r\\n#define w2 (w_onecycles - w_fixedhigh - w1)\\r\\n/* w3   nops to complete loop */\\r\\n#define w3 (w_totalcycles - w_fixedtotal - w1 - w2)\\r\\n\\r\\n#if w1 > 0\\r\\n#define w1_nops w1\\r\\n#else\\r\\n#define w1_nops 0\\r\\n#endif\\r\\n\\r\\n/*\\r\\n  The only critical timing parameter is the minimum pulse length of the \\\"0\\\"\\r\\n  Warn or throw error if this timing can not be met with current F_CPU settings.\\r\\n */\\r\\n#define w_lowtime ( (w1_nops + w_fixedlow) * 1000000) / (F_CPU / 1000)\\r\\n#if w_lowtime > 550\\r\\n#error \\\"Light_ws2812: Sorry, the clock speed is too low. Did you set F_CPU correctly?\\\"\\r\\n#elif w_lowtime > 450\\r\\n#warning \\\"Light_ws2812: The timing is critical and may only work on WS2812B, not on WS2812(S).\\\"\\r\\n#warning \\\"Please consider a higher clockspeed, if possible\\\"\\r\\n#endif\\r\\n\\r\\n#if w2 > 0\\r\\n#define w2_nops w2\\r\\n#else\\r\\n#define w2_nops 0\\r\\n#endif\\r\\n\\r\\n#if w3 > 0\\r\\n#define w3_nops w3\\r\\n#else\\r\\n#define w3_nops 0\\r\\n#endif\\r\\n\\r\\n#define w_nop1  \\\"nop      \\\\n\\\\t\\\"\\r\\n#define w_nop2  \\\"rjmp .+0 \\\\n\\\\t\\\"\\r\\n#define w_nop4  w_nop2 w_nop2\\r\\n#define w_nop8  w_nop4 w_nop4\\r\\n#define w_nop16 w_nop8 w_nop8\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   rgbled_sendarray_mask\\r\\n * \\\\par Description\\r\\n *   Set the LED color for any LED.\\r\\n * \\\\param[in]\\r\\n *   *data - the LED color store memory address\\r\\n * \\\\param[in]\\r\\n *   datlen - the data length need to be transmitted.\\r\\n * \\\\param[in]\\r\\n *   maskhi - the gpio pin mask\\r\\n * \\\\param[in]\\r\\n *   *port - the gpio port address\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nvoid MeNewRGBLed::rgbled_sendarray_mask(uint8_t *data, uint16_t datlen, uint8_t maskhi, uint8_t *port)\\r\\n{\\r\\n  uint8_t curbyte, ctr, masklo;\\r\\n  uint8_t oldSREG = SREG;\\r\\n  cli(); // Disables all interrupts\\r\\n\\r\\n  masklo  = *port & ~maskhi;\\r\\n  maskhi  = *port | maskhi;\\r\\n\\r\\n  while(datlen--)\\r\\n  {\\r\\n    curbyte = *data++;\\r\\n\\r\\n    asm volatile (\\r\\n            \\\"       ldi   %0,8  \\\\n\\\\t\\\"\\r\\n            \\\"loop%=:            \\\\n\\\\t\\\"\\r\\n            \\\"       st    X,%3 \\\\n\\\\t\\\"        //  '1' [02] '0' [02] - re\\r\\n#if (w1_nops & 1)\\r\\n            w_nop1\\r\\n#endif\\r\\n#if (w1_nops & 2)\\r\\n            w_nop2\\r\\n#endif\\r\\n#if (w1_nops & 4)\\r\\n            w_nop4\\r\\n#endif\\r\\n#if (w1_nops & 8)\\r\\n            w_nop8\\r\\n#endif\\r\\n#if (w1_nops & 16)\\r\\n            w_nop16\\r\\n#endif\\r\\n            \\\"       sbrs  %1,7  \\\\n\\\\t\\\"       //  '1' [04] '0' [03]\\r\\n            \\\"       st    X,%4 \\\\n\\\\t\\\"        //  '1' [--] '0' [05] - fe-low\\r\\n            \\\"       lsl   %1    \\\\n\\\\t\\\"       //  '1' [05] '0' [06]\\r\\n#if (w2_nops & 1)\\r\\n            w_nop1\\r\\n#endif\\r\\n#if (w2_nops & 2)\\r\\n            w_nop2\\r\\n#endif\\r\\n#if (w2_nops & 4)\\r\\n            w_nop4\\r\\n#endif\\r\\n#if (w2_nops & 8)\\r\\n            w_nop8\\r\\n#endif\\r\\n#if (w2_nops & 16)\\r\\n            w_nop16\\r\\n#endif\\r\\n            \\\"       brcc skipone%= \\\\n\\\\t\\\"    /*  '1' [+1] '0' [+2] - */\\r\\n            \\\"       st   X,%4      \\\\n\\\\t\\\"    /*  '1' [+3] '0' [--] - fe-high */\\r\\n            \\\"skipone%=:               \\\"     /*  '1' [+3] '0' [+2] - */\\r\\n\\r\\n#if (w3_nops & 1)\\r\\n            w_nop1\\r\\n#endif\\r\\n#if (w3_nops & 2)\\r\\n            w_nop2\\r\\n#endif\\r\\n#if (w3_nops & 4)\\r\\n            w_nop4\\r\\n#endif\\r\\n#if (w3_nops & 8)\\r\\n            w_nop8\\r\\n#endif\\r\\n#if (w3_nops & 16)\\r\\n            w_nop16\\r\\n#endif\\r\\n\\r\\n            \\\"       dec   %0    \\\\n\\\\t\\\"       //  '1' [+4] '0' [+3]\\r\\n            \\\"       brne  loop%=\\\\n\\\\t\\\"       //  '1' [+5] '0' [+4]\\r\\n            : \\\"=&d\\\" (ctr)\\r\\n            : \\\"r\\\" (curbyte), \\\"x\\\" (port), \\\"r\\\" (maskhi), \\\"r\\\" (masklo)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  SREG = oldSREG;\\r\\n}\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   show\\r\\n * \\\\par Description\\r\\n *   Transmission the data to WS2812\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nvoid MeNewRGBLed::show(void)\\r\\n{\\r\\n  if(memcmp(pixels_bak,pixels,3 * count_led) != 0)\\r\\n  {\\r\\n    rgbled_sendarray_mask(pixels, 3 * count_led, pinMask, (uint8_t*)ws2812_port);\\r\\n    memcpy(pixels_bak,pixels,3 * count_led);\\r\\n    delayMicroseconds(500);\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Destructor which can call your own function, it will release the LED buffer\\r\\n */\\r\\nMeNewRGBLed::~MeNewRGBLed(void)\\r\\n{\\r\\n  free(pixels);\\r\\n  pixels = NULL;\\r\\n  free(pixels_bak);\\r\\n  pixels_bak = NULL;\\r\\n}\\r\\n\" }",
    "{ filename: \"src/MeNewRGBLed.h\", code: \"/**\\r\\n * \\\\par Copyright (C), 2014-2018, MakeBlock\\r\\n * \\\\class MeRGBLed\\r\\n * \\\\brief   Driver for W2812 full-color LED lights.\\r\\n * @file    MeRGBLed.h\\r\\n * @author  MakeBlock\\r\\n * @version V1.0.1\\r\\n * @date    2017/06/23\\r\\n * @brief   Header for MeRGBLed.cpp module\\r\\n *\\r\\n * \\\\par Copyright\\r\\n * This software is Copyright (C), 2014-2018, MakeBlock. Use is subject to license \\\\n\\r\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\r\\n *\\r\\n * \\\\par Open Source Licensing GPL V2\\r\\n * This is the appropriate option if you want to share the source code of your \\\\n\\r\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\r\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\r\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\r\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\r\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\r\\n *\\r\\n * \\\\par Description\\r\\n * This file is a drive for WS2811/2812 full-color LED lights, It supports\\r\\n * W2812B full-color LED lights device provided by the MakeBlock.\\r\\n *\\r\\n * \\\\par Method List:\\r\\n *\\r\\n *    1. void MeRGBLed::reset(uint8_t port)\\r\\n *    2. void MeRGBLed::reset(uint8_t port,uint8_t slot)\\r\\n *    3. void MeRGBLed::setpin(uint8_t port)\\r\\n *    4. uint8_t MeRGBLed::getNumber()\\r\\n *    5. cRGB MeRGBLed::getColorAt(uint8_t index)\\r\\n *    6. void MeRGBLed::fillPixelsBak(uint8_t red, uint8_t green, uint8_t blue)\\r\\n *    7. bool MeRGBLed::setColorAt(uint8_t index, uint8_t red, uint8_t green, uint8_t blue)\\r\\n *    8. bool MeRGBLed::setColor(uint8_t index, uint8_t red, uint8_t green, uint8_t blue)\\r\\n *    9. bool MeRGBLed::setColor(uint8_t red, uint8_t green, uint8_t blue)\\r\\n *    10. bool MeRGBLed::setColor(uint8_t index, long value)\\r\\n *    11. void MeRGBLed::show()\\r\\n *\\r\\n * \\\\par History:\\r\\n * <pre>\\r\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\r\\n * Mark Yan         2015/09/01     1.0.0            Rebuild the old lib.\\r\\n * Mark Yan         2017/06/23     1.0.1            Add function fillPixelsBak.\\r\\n * </pre>\\r\\n *\\r\\n * DERIVED FROM\\r\\n * light weight WS2812 lib V2.1 - Arduino support\\r\\n *\\r\\n * Controls WS2811/WS2812/WS2812B RGB-LEDs\\r\\n * Author: Tim (cpldcpu@gmail.com)\\r\\n *\\r\\n * Jan  18th, 2014  v2.0b Initial Version\\r\\n * March 7th, 2014  v2.1  Added option to retarget the port register during runtime\\r\\n *                        Removes inlining to allow compiling with c++\\r\\n *\\r\\n * License: GNU GPL v2 (see License.txt)\\r\\n */\\r\\n#ifndef MeNewRGBLed_h\\r\\n#define MeNewRGBLed_h\\r\\n#include <stdint.h>\\r\\n#include <stdbool.h>\\r\\n#include <Arduino.h>\\r\\n#include \\\"MeConfig.h\\\"\\r\\n\\r\\n\\r\\n#define DEFAULT_MAX_LED_NUMBER  (32)\\r\\n\\r\\n/// @brief Class for RGB Led Module\\r\\nstruct cNewRGB\\r\\n{\\r\\n  uint8_t g;\\r\\n  uint8_t r;\\r\\n  uint8_t b;\\r\\n};\\r\\n\\r\\n/**\\r\\n * Class: MeRGBLed\\r\\n *\\r\\n * \\\\par Description\\r\\n * Declaration of Class MeRGBLed\\r\\n */\\r\\n\\r\\nclass MeNewRGBLed\\r\\n{\\r\\npublic:\\r\\n\\r\\n/**\\r\\n * Alternate Constructor which can call your own function to map the MeRGBLed to arduino port,\\r\\n * it will assigned the LED display buffer and initialization the GPIO of LED lights. You can\\r\\n * set any arduino digital pin for the LED data PIN, The default number of light strips is 32.\\r\\n * \\\\param[in]\\r\\n *   port - arduino port\\r\\n */\\r\\n  MeNewRGBLed(uint8_t port);\\r\\n\\r\\n/**\\r\\n * Alternate Constructor which can call your own function to map the MeRGBLed to arduino port,\\r\\n * it will assigned the LED display buffer and initialization the GPIO of LED lights. You can\\r\\n * set any arduino digital pin for the LED data PIN, and reset the LED number by this constructor.\\r\\n * \\\\param[in]\\r\\n *   port - arduino port\\r\\n * \\\\param[in]\\r\\n *   led_num - The LED number\\r\\n */\\r\\n  MeNewRGBLed(uint8_t port, uint8_t led_num);\\r\\n/**\\r\\n * Destructor which can call your own function, it will release the LED buffer\\r\\n */\\r\\n  ~MeNewRGBLed(void);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setpin\\r\\n * \\\\par Description\\r\\n *   Reset the LED available data PIN by its arduino port.\\r\\n * \\\\param[in]\\r\\n *   port - arduino port(should digital pin)\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n  void setpin(uint8_t port);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   getNumber\\r\\n * \\\\par Description\\r\\n *   Get the LED number you can light it.\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   The total number of LED's\\r\\n * \\\\par Others\\r\\n *   The index value from 1 to the max\\r\\n */\\r\\n  uint8_t getNumber(void);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   getColorAt\\r\\n * \\\\par Description\\r\\n *   Get the LED color value from its index\\r\\n * \\\\param[in]\\r\\n *   index - The LED index number you want to read its value\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   The LED color value, include the R,G,B\\r\\n * \\\\par Others\\r\\n *   The index value from 1 to the max\\r\\n */\\r\\n  cNewRGB getColorAt(uint8_t index);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   fillPixelsBak\\r\\n * \\\\par Description\\r\\n *   fill the LED color data to pixels_bak.\\r\\n * \\\\param[in]\\r\\n *   red - Red values\\r\\n * \\\\param[in]\\r\\n *   green - green values\\r\\n * \\\\param[in]\\r\\n *   blue - blue values\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\nvoid fillPixelsBak(uint8_t red, uint8_t green, uint8_t blue);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setColorAt\\r\\n * \\\\par Description\\r\\n *   Set the LED color for any LED.\\r\\n * \\\\param[in]\\r\\n *   index - The LED index number you want to set its color\\r\\n * \\\\param[in]\\r\\n *   red - Red values\\r\\n * \\\\param[in]\\r\\n *   green - green values\\r\\n * \\\\param[in]\\r\\n *   blue - blue values\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   The index value from 0 to the max.\\r\\n */\\r\\nbool setColorAt(uint8_t index, uint8_t red, uint8_t green, uint8_t blue);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setColor\\r\\n * \\\\par Description\\r\\n *   Set the LED color for any LED.\\r\\n * \\\\param[in]\\r\\n *   index - The LED index number you want to set its color\\r\\n * \\\\param[in]\\r\\n *   red - Red values\\r\\n * \\\\param[in]\\r\\n *   green - green values\\r\\n * \\\\param[in]\\r\\n *   blue - blue values\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   The index value from 1 to the max, if you set the index 0, all the LED will be lit\\r\\n */\\r\\n  bool setColor(uint8_t index, uint8_t red, uint8_t green, uint8_t blue);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setColor\\r\\n * \\\\par Description\\r\\n *   Set the LED color for all LED.\\r\\n * \\\\param[in]\\r\\n *   red - Red values\\r\\n * \\\\param[in]\\r\\n *   green - green values\\r\\n * \\\\param[in]\\r\\n *   blue - blue values\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   All the LED will be lit.\\r\\n */\\r\\n  bool setColor(uint8_t red, uint8_t green, uint8_t blue);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setColor\\r\\n * \\\\par Description\\r\\n *   Set the LED color for any LED.\\r\\n * \\\\param[in]\\r\\n *   value - the LED color defined as long type, for example (white) = 0xFFFFFF\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   The index value from 1 to the max, if you set the index 0, all the LED will be lit\\r\\n */\\r\\n  bool setColor(uint8_t index, long value);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   setNumber\\r\\n * \\\\par Description\\r\\n *   Assigned the LED display buffer by the LED number\\r\\n * \\\\param[in]\\r\\n *   num_leds - The LED number you used\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n  void setNumber(uint8_t num_led);\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   show\\r\\n * \\\\par Description\\r\\n *   Transmission the data to WS2812\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   None\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n  void show(void);\\r\\n\\r\\nprivate:\\r\\n  uint16_t count_led;\\r\\n  uint8_t *pixels;\\r\\n  uint8_t *pixels_bak;\\r\\n\\r\\n/**\\r\\n * \\\\par Function\\r\\n *   rgbled_sendarray_mask\\r\\n * \\\\par Description\\r\\n *   Set the LED color for any LED.\\r\\n * \\\\param[in]\\r\\n *   *data - the LED color store memory address\\r\\n * \\\\param[in]\\r\\n *   datlen - the data length need to be transmitted.\\r\\n * \\\\param[in]\\r\\n *   maskhi - the gpio pin mask\\r\\n * \\\\param[in]\\r\\n *   *port - the gpio port address\\r\\n * \\\\par Output\\r\\n *   None\\r\\n * \\\\return\\r\\n *   TRUE: Successful implementation\\r\\n *   FALSE: Wrong execution\\r\\n * \\\\par Others\\r\\n *   None\\r\\n */\\r\\n  void rgbled_sendarray_mask(uint8_t *array, uint16_t length, uint8_t pinmask, uint8_t *port);\\r\\n\\r\\n  const volatile uint8_t *ws2812_port;\\r\\n  volatile uint8_t *ws2812_port_reg;\\r\\n  uint8_t pinMask;\\r\\n};\\r\\n#endif\\r\\n\" }"
];