export default [
    "{ filename: \"src/MeRGBLineFollower.cpp\", code: \"/**\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\n * \\\\class   MeRGBLineFollower\\n * \\\\brief   Driver for MeRGBLineFollower module.\\n * @file    MeRGBLineFollower.cpp\\n * @author  MakeBlock\\n * @version V1.0.0\\n * @date    2017/09/26\\n * @brief   Driver for MeRGBLineFollower module.\\n *\\n * \\\\par Copyright\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\n *\\n * \\\\par Open Source Licensing GPL V2\\n * This is the appropriate option if you want to share the source code of your \\\\n\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\n *\\n * \\\\par Description\\n * This file is a drive for MeRGBLineFollower module, It supports MeRGBLineFollower V1.0 device provided\\n * by MakeBlock.\\n *\\n * \\\\par Method List:\\n *\\n *    1.void MeRGBLineFollower::setpin(uint8_t AD0, uint8_t INT)\\n *\\t \\t2.void MeRGBLineFollower::begin(void)\\n *    3.uint8_t MeRGBLineFollower::getDevAddr(void)\\n *    4.uint8_t MeRGBLineFollower::getADCValueRGB1(void)\\n *    5.uint8_t MeRGBLineFollower::getADCValueRGB2(void)\\n *    6.uint8_t MeRGBLineFollower::getADCValueRGB3(void)\\n *    7.uint8_t MeRGBLineFollower::getADCValueRGB4(void)\\n *    8.void MeRGBLineFollower::setKp(float value)\\n *    9.int16_t MeRGBLineFollower::getPositionOffset(void)\\n *    10.uint8_t MeRGBLineFollower::getPositionState(void)\\n *    11.uint8_t MeRGBLineFollower::getIicErrorCnt(void)\\n *    12.uint8_t MeRGBLineFollower::getStudyTypes(void)\\n *    13.void MeRGBLineFollower::updataAllSensorValue(void)\\n *    14.int8_t MeRGBLineFollower::readData(uint8_t start, uint8_t *buffer, uint8_t size)\\n *    15.int8_t MeRGBLineFollower::writeReg(uint8_t reg, uint8_t data)\\n *    16.int8_t MeRGBLineFollower::writeData(uint8_t start, const uint8_t *pData, uint8_t size)\\n *\\n * \\\\par History:\\n * <pre>\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\n *  Payton            2017/09/26        1.0.0         rebuild the old lib.\\n *  Payton            2018/07/31        1.0.1         deletel #include <Wire.h> and #include <SoftwareSerial.h>\\n * </pre>\\n *\\n * @example MeRGBLineFollowerTest.ino\\n */\\n\\n/* Includes ------------------------------------------------------------------*/\\n#include \\\"MeRGBLineFollower.h\\\"\\n\\n#include <Arduino.h>\\n\\n/* Private functions ---------------------------------------------------------*/\\n#ifdef ME_PORT_DEFINED\\n/**\\n * Alternate Constructor which can call your own function to map the MeRGBLineFollower to arduino port,\\n * no pins are used or initialized here\\n */\\nMeRGBLineFollower::MeRGBLineFollower(void) : MePort(0)\\n{\\n  Device_Address = RGBLINEFOLLOWER_DEFAULT_ADDRESS;\\n}\\n\\n/**\\n * Alternate Constructor which can call your own function to map the MeRGBLineFollower to arduino port,\\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\\n * \\\\param[in]\\n *   port - RJ25 port from PORT_1 to M2\\n */\\nMeRGBLineFollower::MeRGBLineFollower(uint8_t port) : MePort(port)\\n{\\n  Device_Address = RGBLINEFOLLOWER_DEFAULT_ADDRESS;\\n}\\n\\n/**\\n * Alternate Constructor which can call your own function to map the MeRGBLineFollower to arduino port\\n * and change the i2c device address\\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\\n * \\\\param[in]\\n *   port - RJ25 port from PORT_1 to M2\\n * \\\\param[in]\\n *   address - the i2c address you want to set(0~3), If it's another value,it will be set to 0\\n */\\nMeRGBLineFollower::MeRGBLineFollower(uint8_t port, uint8_t address) : MePort(port)\\n{\\n  //address0-11, address1-10, address2-01, address3-00\\n  pinMode(s1, OUTPUT);\\n  pinMode(s2, OUTPUT);\\n  if(address == ADDRESS1)\\n  {\\n    digitalWrite(s1,HIGH);\\n    digitalWrite(s2,HIGH);\\n  }\\n  else if(address == ADDRESS2)\\n  {\\n    digitalWrite(s1,LOW);\\n    digitalWrite(s2,HIGH);\\n  }\\n  else if(address == ADDRESS3)\\n  {\\n    digitalWrite(s1,HIGH);\\n    digitalWrite(s2,LOW);\\n  }\\n  else if(address == ADDRESS4)\\n  {\\n    digitalWrite(s1,LOW);\\n    digitalWrite(s2,LOW);\\n  }\\n  else\\n  { \\n    digitalWrite(s1,HIGH);\\n    digitalWrite(s2,HIGH);\\n    address = ADDRESS1;\\n  }\\n\\n  Device_Address = RGBLINEFOLLOWER_DEFAULT_ADDRESS + address;\\n}\\n#else  // ME_PORT_DEFINED\\n/**\\n * Alternate Constructor which can call your own function to map the AD0 and INT to arduino port,\\n * no pins are used or initialized here\\n * \\\\param[in]\\n *   AD0 - arduino gpio number\\n * \\\\param[in]\\n *   INT - arduino gpio number\\n  * \\\\param[in]\\n *   address - the i2c address you want to set(0~3), If it's another value,it will be set to 0\\n */\\nMeRGBLineFollower::MeRGBLineFollower(uint8_t AD0, uint8_t INT, uint8_t address)\\n{\\n  pinMode(AD0,OUTPUT);\\n  pinMode(INT,OUTPUT);\\n\\n  //address0-11, address1-10, address2-01, address3-00\\n  if(address == ADDRESS1)\\n  {\\n    digitalWrite(AD0,HIGH);\\n    digitalWrite(INT,HIGH);\\n  }\\n  else if(address == ADDRESS2)\\n  {\\n    digitalWrite(AD0,LOW);\\n    digitalWrite(INT,HIGH);\\n  }\\n  else if(address == ADDRESS3)\\n  {\\n    digitalWrite(AD0,HIGH);\\n    digitalWrite(INT,LOW);\\n  }\\n  else if(address == ADDRESS4)\\n  {\\n    digitalWrite(AD0,LOW);\\n    digitalWrite(INT,LOW);\\n  }\\n  else\\n  { \\n    digitalWrite(AD0,HIGH);\\n    digitalWrite(INT,HIGH);\\n    address = ADDRESS1;\\n  }\\n\\n  Device_Address = RGBLINEFOLLOWER_DEFAULT_ADDRESS + address;\\n}\\n\\n#endif // ME_PORT_DEFINED\\n\\n/**\\n * \\\\par Function\\n *   setpin\\n * \\\\par Description\\n *   Set the PIN of the button module.\\n * \\\\param[in]\\n *   AD0 - pin mapping for arduino\\n * \\\\param[in]\\n *   INT - pin mapping for arduino\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None.\\n * \\\\par Others\\n *   Set global variable AD0, INT, s1 and s2\\n */\\nvoid MeRGBLineFollower::setpin(uint8_t AD0, uint8_t INT)\\n{\\n  pinMode(AD0,OUTPUT);\\n  pinMode(INT,OUTPUT);\\n\\n#ifdef ME_PORT_DEFINED\\n  s1 = AD0;\\n  s2 = INT;\\n#endif // ME_PORT_DEFINED\\n}\\n\\n/**\\n * \\\\par Function\\n *   begin\\n * \\\\par Description\\n *   Initialize the MeRGBLineFollower.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n *   \\n */\\nvoid MeRGBLineFollower::begin(void)\\n{\\n  uint8_t i;\\n  \\n  Kp = 0.3;\\n  study_types = STUDY_IDLE;\\n  iic_error_count = 0;\\n  \\n  Wire.begin();\\n  delay(10);\\n}\\n\\n/**\\n * \\\\par Function\\n *   getDevAddr\\n * \\\\par Description\\n *   Get the device address of MeRGBLineFollower.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The device address of MeRGBLineFollower\\n * \\\\par Others\\n *   None\\n */\\nuint8_t MeRGBLineFollower::getDevAddr(void)\\n{\\n  return Device_Address;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getADCValueRGB1\\n * \\\\par Description\\n *   Get the RGB1 sensor ADC value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The ADC value of RGB1\\n * \\\\par Others\\n *   \\n */\\nuint8_t MeRGBLineFollower::getADCValueRGB1(void)\\n{\\n  return adcOutput[RGB1_INDEX];\\n}\\n\\n/**\\n * \\\\par Function\\n *   getADCValueRGB2\\n * \\\\par Description\\n *   Get the RGB2 sensor ADC value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The ADC value of RGB2\\n * \\\\par Others\\n *   \\n */\\nuint8_t MeRGBLineFollower::getADCValueRGB2(void)\\n{\\n  return adcOutput[RGB2_INDEX];\\n}\\n\\n/**\\n * \\\\par Function\\n *   getADCValueRGB3\\n * \\\\par Description\\n *   Get the RGB3 sensor ADC value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The ADC value of RGB3\\n * \\\\par Others\\n *   \\n */\\nuint8_t MeRGBLineFollower::getADCValueRGB3(void)\\n{\\n  return adcOutput[RGB3_INDEX];\\n}\\n\\n/**\\n * \\\\par Function\\n *   getADCValueRGB4\\n * \\\\par Description\\n *   Get the RGB4 sensor ADC value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The ADC value of RGB4\\n * \\\\par Others\\n *   \\n */\\nuint8_t MeRGBLineFollower::getADCValueRGB4(void)\\n{\\n  return adcOutput[RGB4_INDEX];\\n}\\n\\n/**\\n * \\\\par Function\\n *   setKp\\n * \\\\par Description\\n *   set Kp.\\n * \\\\param[in]\\n *   value: 0 ~ 1，turn sensitivity\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n *  \\n */\\nvoid MeRGBLineFollower::setKp(float value)\\n{\\n  if((value >= 0) && (value <= 1))\\n  {\\n    Kp = value;\\n  }\\n}\\n\\n/**\\n * \\\\par Function\\n *   getPositionOffset\\n * \\\\par Description\\n *   get turn Value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Position offset Value,-512 ~ 512\\n      <0,in right\\n      >0,in left\\n * \\\\par Others\\n *   |---------------------------|\\n     |      |      |      |      |\\n     |RGB1  |RGB2  |RGB3  |RGB4  |\\n     |      |      |      |      |\\n     |---------------------------|\\n */\\nint16_t MeRGBLineFollower::getPositionOffset(void)\\n{\\n  return positionOffset;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getPositionState\\n * \\\\par Description\\n *   get turn Value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Position StateValue,0x00~0x0F,bit0-RGB1,bit1-RGB2 ,bit2-RGB3  ,bit3-RGB4 \\n * \\\\par Others\\n *   |---------------------------|\\n     |      |      |      |      |\\n     |RGB1  |RGB2  |RGB3  |RGB4  |\\n     |      |      |      |      |\\n     |---------------------------|\\n */\\nuint8_t MeRGBLineFollower::getPositionState(void)\\n{\\n  return positionState;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getPositionState\\n * \\\\par Description\\n *   get turn Value.\\n * \\\\param[in]\\n *   Speed:set forward speed\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n */\\n//uint8_t MeRGBLineFollower::getIICErrorCnt(void)\\n//{\\n//  return iic_error_count;\\n//}\\n\\n/**\\n * \\\\par Function\\n *   getStudyTypes\\n * \\\\par Description\\n *   get turn Value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Study types\\n*    0. STUDY_IDLE\\n*    1. STUDY_BACKGROUND\\n*    2. STUDY_TRACK\\n * \\\\par Others\\n */\\nuint8_t MeRGBLineFollower::getStudyTypes(void)\\n{\\n  return study_types;\\n}\\n\\n/**\\n * \\\\par Function\\n *   updataAllSensorValue\\n * \\\\par Description\\n *   updata All Sensor Value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   \\n * \\\\par Others\\n */\\nvoid MeRGBLineFollower::updataAllSensorValue(void)\\n{\\n  int8_t return_value;\\n  int16_t temp_positionOffset;\\n  \\n  /* read data */\\n  return_value = readData(RGBLINEFOLLOWER_DEVICE_ID_ADDR, &i2cData[0], 8);\\n  if(return_value == I2C_OK)\\n  {\\n    if(i2cData[RGBLINEFOLLOWER_DEVICE_ID_ADDR] == RGBLINEFOLLOWER_DEVICE_ID)\\n    {\\n      adcOutput[RGB1_INDEX] = i2cData[RGBLINEFOLLOWER_RGB1_ADDR];\\n      adcOutput[RGB2_INDEX] = i2cData[RGBLINEFOLLOWER_RGB2_ADDR];\\n      adcOutput[RGB3_INDEX] = i2cData[RGBLINEFOLLOWER_RGB3_ADDR];\\n      adcOutput[RGB4_INDEX] = i2cData[RGBLINEFOLLOWER_RGB4_ADDR];\\n      temp_positionOffset = (int16_t)(i2cData[RGBLINEFOLLOWER_TURNOFFSET_L_ADDR] | ((uint16_t)i2cData[RGBLINEFOLLOWER_TURNOFFSET_H_ADDR]<<8));\\n      temp_positionOffset = (int16_t)(Kp * temp_positionOffset);\\n      positionOffset= constrain(temp_positionOffset, -512, 512);\\n      positionState = i2cData[RGBLINEFOLLOWER_STATE_ADDR] & 0x0F;\\n      study_types = (i2cData[RGBLINEFOLLOWER_STATE_ADDR]>>4) & 0x03;\\n    }\\n    else\\n    {\\n      iic_error_count++;  \\n      //Serial.print(\\\"iic error:\\\");\\n      //Serial.println(iic_error_count);\\n    }\\n  }\\n\\n//  Serial.print(\\\"i2cData[0]:\\\");\\n//  Serial.print(i2cData[0]);\\n//  Serial.print(\\\"  i2cData[1]:\\\");\\n//  Serial.print(i2cData[1]);\\n//  Serial.print(\\\"  i2cData[2]:\\\");\\n//  Serial.print(i2cData[2]);\\n//  Serial.print(\\\"  i2cData[3]:\\\");\\n//  Serial.print(i2cData[3]);\\n//  Serial.print(\\\"  i2cData[4]:\\\");\\n//  Serial.print(i2cData[4]);\\n//  Serial.print(\\\"  i2cData[5]:\\\");\\n//  Serial.print(i2cData[5]);\\n//  Serial.print(\\\"  i2cData[6]:\\\");\\n//  Serial.print(i2cData[6]);\\n//  Serial.print(\\\"  i2cData[7]:\\\");\\n//  Serial.print(i2cData[7]);\\n//  Serial.println(\\\"  \\\");\\n}\\n\\n/**\\n * \\\\par Function\\n *   studyBackground\\n * \\\\par Description\\n *   study background.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n */\\nint8_t MeRGBLineFollower::studyBackground(void)\\n{\\n  int8_t return_value = 0;\\n  uint8_t data = STUDY_BACKGROUND;\\n  return_value = writeReg(RGBLINEFOLLOWER_STUDY_ADDR, data);\\n  return(return_value);\\n}\\n\\n/**\\n * \\\\par Function\\n *   studyTrack\\n * \\\\par Description\\n *   study track.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n */\\nint8_t MeRGBLineFollower::studyTrack(void)\\n{\\n  int8_t return_value = 0;\\n  uint8_t data = STUDY_TRACK;\\n  return_value = writeReg(RGBLINEFOLLOWER_STUDY_ADDR, data);\\n  return(return_value);\\n}\\n\\n/**\\n * \\\\par Function\\n *   setRGBColour\\n * \\\\par Description\\n *   Set the RGB colour.\\n * \\\\param[in]\\n *   types:RGB_COLOUR_RED, RGB_COLOUR_GREEN, RGB_COLOUR_BLUE\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n */\\nint8_t MeRGBLineFollower::setRGBColour(uint8_t colour)\\n{\\n  int8_t return_value = 0;\\n  uint8_t data = colour;\\n  return_value = writeReg(RGBLINEFOLLOWER_SET_RGB_ADDR, data);\\n  return(return_value);\\n}\\n\\n/**\\n * \\\\par Function\\n *   setBackgroundThreshold\\n * \\\\par Description\\n *   set Background Threshold.\\n * \\\\param[in]\\n *   ch:RGB index\\n *      0.RGB1_INDEX\\n *      1.RGB2_INDEX\\n *      2.RGB3_INDEX\\n *      3.RGB4_INDEX\\n *   threshold:0~255\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n */\\nint8_t MeRGBLineFollower::setBackgroundThreshold(uint8_t ch, uint8_t threshold)\\n{\\n  int8_t return_value = 0;\\n  uint8_t data = threshold;\\n\\n  if(ch > RGB4_INDEX)\\n  {\\n    return I2C_ERROR;\\n  }\\n  \\n  return_value = writeReg(RGBLINEFOLLOWER_RGB1_BACKGROUND_THRESHOLD_ADDR + ch, data);\\n  return(return_value);\\n}\\n\\n/**\\n * \\\\par Function\\n *   setTrackThreshold\\n * \\\\par Description\\n *   set track Threshold.\\n * \\\\param[in]\\n *   ch:RGB index\\n *      0.RGB1_INDEX\\n *      1.RGB2_INDEX\\n *      2.RGB3_INDEX\\n *      3.RGB4_INDEX\\n *   threshold:0~255\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n */\\nint8_t MeRGBLineFollower::setTrackThreshold(uint8_t ch, uint8_t threshold)\\n{\\n  int8_t return_value = 0;\\n  uint8_t data = threshold;\\n\\n  if(ch > RGB4_INDEX)\\n  {\\n    return I2C_ERROR;\\n  }\\n  \\n  return_value = writeReg(RGBLINEFOLLOWER_RGB1_TRACK_THRESHOLD_ADDR + ch, data);\\n  return(return_value);\\n}\\n\\n/**\\n * \\\\par Function\\n *   getBackgroundThreshold\\n * \\\\par Description\\n *   Get the background threshold .\\n * \\\\param[in]\\n *   ch:RGB index\\n *      0.RGB1_INDEX\\n *      1.RGB2_INDEX\\n *      2.RGB3_INDEX\\n *      3.RGB4_INDEX\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the background threshold. 0~255\\n * \\\\par Others\\n */\\nuint8_t MeRGBLineFollower::getBackgroundThreshold(uint8_t ch)\\n{\\n  int8_t return_value = 0;\\n  uint8_t reg = RGBLINEFOLLOWER_RGB1_BACKGROUND_THRESHOLD_ADDR + ch;\\n  \\n  if(ch <= RGB4_INDEX)\\n  {\\n    return_value = readData(reg, &i2cData[reg], 1);\\n    delay(50);\\n    if(return_value == I2C_OK)\\n    {\\n      return i2cData[reg];\\n    }\\n    return i2cData[reg];\\n  }\\n  \\n  return 0;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getTrackThreshold\\n * \\\\par Description\\n *   Get the track threshold .\\n * \\\\param[in]\\n *   ch:RGB index\\n *      0.RGB1_INDEX\\n *      1.RGB2_INDEX\\n *      2.RGB3_INDEX\\n *      3.RGB4_INDEX\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the track threshold. 0~255\\n * \\\\par Others\\n */\\nuint8_t MeRGBLineFollower::getTrackThreshold(uint8_t ch)\\n{\\n  int8_t return_value = 0;\\n  uint8_t reg = RGBLINEFOLLOWER_RGB1_TRACK_THRESHOLD_ADDR + ch;\\n  \\n  if(ch <= RGB4_INDEX)\\n  {\\n    return_value = readData(reg, &i2cData[reg], 1);\\n    if(return_value == I2C_OK)\\n    {\\n      return i2cData[reg];\\n    }\\n    return i2cData[reg];\\n  }\\n  \\n  return 0;\\n}\\n\\n/**\\n * \\\\par Function\\n *   getFirmwareVersion\\n * \\\\par Description\\n *   Get Firmware Version.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   buffer: for storage version, length greater than 8\\n * \\\\return\\n *   None\\n * \\\\par Others\\n */\\nvoid MeRGBLineFollower::getFirmwareVersion(char *buffer)\\n{\\n  int8_t return_value = 0;\\n  uint8_t reg = RGBLINEFOLLOWER_GET_VERSION_ADDR;\\n\\n  return_value = readData(reg, &i2cData[reg], 8);\\n  if(return_value == I2C_OK)\\n  {\\n    memcpy(buffer, &i2cData[reg], 8);\\n  }\\n  memcpy(buffer, &i2cData[reg], 8);\\n}\\n\\n/**\\n * \\\\par Function\\n *   writeReg\\n * \\\\par Description\\n *   Write the registor of i2c device.\\n * \\\\param[in]\\n *   reg - the address of registor.\\n * \\\\param[in]\\n *   data - the data that will be written to the registor.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   To set the registor for initializing.\\n */\\nint8_t MeRGBLineFollower::writeReg(uint8_t reg, uint8_t data)\\n{\\n  int8_t return_value = 0;\\n  return_value = writeData(reg, &data, 1);\\n  delay(5);\\n  return(return_value);\\n}\\n\\n/**\\n * \\\\par Function\\n *   readData\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to read data.\\n */\\nint8_t MeRGBLineFollower::readData(uint8_t start, uint8_t *buffer, uint8_t size)\\n{\\n  int16_t i = 0;\\n  int8_t return_value = 0;\\n\\n  Wire.beginTransmission(Device_Address);\\n  return_value = Wire.write(start);\\n  if(return_value != 1)\\n  {\\n    return(I2C_ERROR);\\n  }\\n  return_value = Wire.endTransmission(false);\\n  if(return_value != 0)\\n  {\\n    return(return_value);\\n  }\\n  delayMicroseconds(1);\\n  /* Third parameter is true: relase I2C-bus after data is read. */\\n  Wire.requestFrom(Device_Address, size, (uint8_t)true);\\n  while(Wire.available() && i < size)\\n  {\\n    buffer[i++] = Wire.read();\\n  }\\n  delayMicroseconds(1);\\n  if(i != size)\\n  {\\n    return(I2C_ERROR);\\n  }\\n  return(0); //return: no error \\n}\\n\\n/**\\n * \\\\par Function\\n *   writeData\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to write data.\\n */\\nint8_t MeRGBLineFollower::writeData(uint8_t start, const uint8_t *pData, uint8_t size)\\n{\\n  int8_t return_value = 0;\\n  Wire.beginTransmission(Device_Address);\\n  return_value = Wire.write(start); \\n  if(return_value != 1)\\n  {\\n    return(I2C_ERROR);\\n  }\\n  Wire.write(pData, size);  \\n  return_value = Wire.endTransmission(true); \\n  return(return_value); //return: no error                     \\n}\\n\\n/**\\n * \\\\par Function\\n *\\t loop\\n * \\\\par Description\\n *\\tRGBLineFollower loop.\\n * \\\\param[in]\\n *\\t None\\n * \\\\par Output\\n *\\t None\\n * \\\\return\\n *\\t \\n * \\\\par Others\\n */\\nvoid MeRGBLineFollower::loop(void)\\n{\\n  if(millis() - updata_time > 8)  \\n  {\\n    updata_time = millis();\\n    updataAllSensorValue();\\n  }\\n}\\n\" }",
    "{ filename: \"src/MeRGBLineFollower.h\", code: \"/**\\n * \\\\par Copyright (C), 2012-2016, MakeBlock\\n * \\\\class   MeRGBLineFollower\\n * \\\\brief   Driver for MeRGBLineFollower module.\\n * @file   MeRGBLineFollower.h\\n * @author  MakeBlock\\n * @version V1.0.0\\n * @date    2017/09/26\\n * @brief   Header for MeRGBLineFollower.cpp module.\\n *\\n * \\\\par Copyright\\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \\\\n\\n * conditions. The main licensing options available are GPL V2 or Commercial: \\\\n\\n *\\n * \\\\par Open Source Licensing GPL V2\\n * This is the appropriate option if you want to share the source code of your \\\\n\\n * application with everyone you distribute it to, and you also want to give them \\\\n\\n * the right to share who uses it. If you wish to use this software under Open \\\\n\\n * Source Licensing, you must contribute all your source code to the open source \\\\n\\n * community in accordance with the GPL Version 2 when your application is \\\\n\\n * distributed. See http://www.gnu.org/copyleft/gpl.html\\n *\\n * \\\\par Description\\n * This file is a drive for MeRGBLineFollower module, It supports MeRGBLineFollower V1.0 device provided\\n * by MakeBlock.\\n *\\n * \\\\par Method List:\\n *\\n *    1.void MeRGBLineFollower::setpin(uint8_t AD0, uint8_t INT)\\n *\\t \\t2.void MeRGBLineFollower::begin(void)\\n *    3.uint8_t MeRGBLineFollower::getDevAddr(void)\\n *    4.uint8_t MeRGBLineFollower::getADCValueRGB1(void)\\n *    5.uint8_t MeRGBLineFollower::getADCValueRGB2(void)\\n *    6.uint8_t MeRGBLineFollower::getADCValueRGB3(void)\\n *    7.uint8_t MeRGBLineFollower::getADCValueRGB4(void)\\n *    8.void MeRGBLineFollower::setKp(float value)\\n *    9.int16_t MeRGBLineFollower::getPositionOffset(void)\\n *    10.uint8_t MeRGBLineFollower::getPositionState(void)\\n *    11.uint8_t MeRGBLineFollower::getIicErrorCnt(void)\\n *    12.uint8_t MeRGBLineFollower::getStudyTypes(void)\\n *    13.void MeRGBLineFollower::updataAllSensorValue(void)\\n *    14.int8_t MeRGBLineFollower::readData(uint8_t start, uint8_t *buffer, uint8_t size)\\n *    15.int8_t MeRGBLineFollower::writeReg(uint8_t reg, uint8_t data)\\n *    16.int8_t MeRGBLineFollower::writeData(uint8_t start, const uint8_t *pData, uint8_t size)\\n *\\n * \\\\par History:\\n * <pre>\\n * \\\"<Author>\\\"         \\\"<Time>\\\"        \\\"<Version>\\\"        \\\"<Descr>\\\"\\n *  Payton            2017/09/26          1.0.0         rebuild the old lib.\\n *  Payton            2018/07/31          1.0.1         deletel #include <Wire.h> and #include <SoftwareSerial.h>\\n * </pre>\\n *\\n */\\n\\n/* Define to prevent recursive inclusion -------------------------------------*/\\n#ifndef MeRGBLineFollower_H\\n#define MeRGBLineFollower_H\\n\\n/* Includes ------------------------------------------------------------------*/\\n#include <stdint.h>\\n#include <stdbool.h>\\n#include <Arduino.h>\\n#include \\\"MeConfig.h\\\"\\n#ifdef ME_PORT_DEFINED\\n#include \\\"MePort.h\\\"\\n#endif // ME_PORT_DEFINED\\n\\n/* Exported macro ------------------------------------------------------------*/\\n#define I2C_ERROR                  \\t\\t\\t\\t\\t\\t(-1)\\n#define I2C_OK                    \\t\\t\\t\\t\\t\\t(0)\\n#define RGBLINEFOLLOWER_DEFAULT_ADDRESS      (0x20)\\n#define RGBLINEFOLLOWER_DEVICE_ID\\t\\t\\t\\t\\t\\t\\t(0xFA)\\n\\n//RGBLineFollower IIC Register Address\\n#define RGBLINEFOLLOWER_DEVICE_ID_ADDR                  (0x00)\\n#define RGBLINEFOLLOWER_RGB1_ADDR                       (0x01)\\n#define RGBLINEFOLLOWER_RGB2_ADDR                       (0x02)\\n#define RGBLINEFOLLOWER_RGB3_ADDR                       (0x03)\\n#define RGBLINEFOLLOWER_RGB4_ADDR                       (0x04)\\n#define RGBLINEFOLLOWER_TURNOFFSET_L_ADDR               (0x05)\\n#define RGBLINEFOLLOWER_TURNOFFSET_H_ADDR               (0x06)\\n#define RGBLINEFOLLOWER_STATE_ADDR       \\t              (0x07)\\n#define RGBLINEFOLLOWER_RGB1_BACKGROUND_THRESHOLD_ADDR  (0x08)\\n#define RGBLINEFOLLOWER_RGB2_BACKGROUND_THRESHOLD_ADDR  (0x09)\\n#define RGBLINEFOLLOWER_RGB3_BACKGROUND_THRESHOLD_ADDR  (0x0A)\\n#define RGBLINEFOLLOWER_RGB4_BACKGROUND_THRESHOLD_ADDR  (0x0B)\\n#define RGBLINEFOLLOWER_RGB1_TRACK_THRESHOLD_ADDR       (0x0C)\\n#define RGBLINEFOLLOWER_RGB2_TRACK_THRESHOLD_ADDR       (0x0D)\\n#define RGBLINEFOLLOWER_RGB3_TRACK_THRESHOLD_ADDR       (0x0E)\\n#define RGBLINEFOLLOWER_RGB4_TRACK_THRESHOLD_ADDR       (0x0F)\\n#define RGBLINEFOLLOWER_GET_VERSION_ADDR                (0x10)\\n#define RGBLINEFOLLOWER_STUDY_ADDR                      (0x31)\\n#define RGBLINEFOLLOWER_SET_RGB_ADDR                    (0x32)\\n\\n\\n//RGBLineFollower index\\n#define RGB1_INDEX\\t\\t0\\n#define RGB2_INDEX\\t\\t1\\n#define RGB3_INDEX\\t\\t2\\n#define RGB4_INDEX\\t\\t3\\n\\n//RGBLineFollower number\\n#define RGBLINEFOLLOWER_NUM\\t\\t         (0x04)\\n\\n//address\\n#define ADDRESS1\\t\\t0\\n#define ADDRESS2\\t\\t1\\n#define ADDRESS3\\t\\t2\\n#define ADDRESS4\\t\\t3\\n\\n//study types\\n#define STUDY_IDLE          0\\n#define STUDY_BACKGROUND    1\\n#define STUDY_TRACK         2\\n\\n\\n//RGB culour\\n#define RGB_COLOUR_RED      1\\n#define RGB_COLOUR_GREEN    2\\n#define RGB_COLOUR_BLUE     3\\n\\n/**\\n * Class: MeRGBLineFollower\\n * \\\\par Description\\n * Declaration of Class MeRGBLineFollower\\n */\\n#ifndef ME_PORT_DEFINED\\nclass MeRGBLineFollower\\n#else // !ME_PORT_DEFINED\\nclass MeRGBLineFollower : public MePort\\n#endif // !ME_PORT_DEFINED\\n{\\npublic:\\n#ifdef ME_PORT_DEFINED\\n/**\\n * Alternate Constructor which can call your own function to map the MeCompass to arduino port,\\n * no pins are used or initialized here\\n */\\n  MeRGBLineFollower(void);\\n\\n/**\\n * Alternate Constructor which can call your own function to map the MeCompass to arduino port,\\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\\n * \\\\param[in]\\n *   port - RJ25 port from PORT_1 to M2\\n */\\n  MeRGBLineFollower(uint8_t port);\\n\\n/**\\n * Alternate Constructor which can call your own function to map the MeCompass to arduino port\\n * and change the i2c device address\\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\\n * \\\\param[in]\\n *   port - RJ25 port from PORT_1 to M2\\n * \\\\param[in]\\n *   address - the i2c address you want to set\\n */\\n  MeRGBLineFollower(uint8_t port, uint8_t address);\\n#else\\n/**\\n * Alternate Constructor which can call your own function to map the AD0 and INT to arduino port,\\n * no pins are used or initialized here\\n * \\\\param[in]\\n *   AD0 - arduino gpio number\\n * \\\\param[in]\\n *   INT - arduino gpio number\\n  * \\\\param[in]\\n *   address - the i2c address you want to set(0~3), If it's another value,it will be set to 0\\n */\\n MeRGBLineFollower(uint8_t AD0, uint8_t INT, uint8_t address);\\n\\n#endif  //  ME_PORT_DEFINED\\n/**\\n * \\\\par Function\\n *   setpin\\n * \\\\par Description\\n *   Set the PIN of the button module.\\n * \\\\param[in]\\n *   AD0 - pin mapping for arduino\\n * \\\\param[in]\\n *   INT - pin mapping for arduino\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None.\\n * \\\\par Others\\n *   Set global variable _AD0, _INT, s1 and s2\\n */\\n  void setpin(uint8_t AD0, uint8_t INT);\\n\\n/**\\n * \\\\par Function\\n *   begin\\n * \\\\par Description\\n *   Initialize the MeRGBLineFollower.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n *   None\\n */\\n  void begin();\\n\\n/**\\n * \\\\par Function\\n *   getDevAddr\\n * \\\\par Description\\n *   Get the device address of RGBLineFollower.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The device address of RGBLineFollower\\n * \\\\par Others\\n *   None\\n */\\n  uint8_t getDevAddr(void);\\n\\n/**\\n * \\\\par Function\\n *   getADCValueRGB1\\n * \\\\par Description\\n *   Get the RGB1 sensor ADC value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The ADC value of RGB1:0~255\\n * \\\\par Others\\n *   \\n */\\n\\tuint8_t getADCValueRGB1(void);\\n\\n/**\\n * \\\\par Function\\n *   getADCValueRGB2\\n * \\\\par Description\\n *   Get the RGB2 sensor ADC value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The ADC value of RGB2:0~255\\n * \\\\par Others\\n *   \\n */\\n\\tuint8_t getADCValueRGB2(void);\\n\\n/**\\n * \\\\par Function\\n *   getADCValueRGB3\\n * \\\\par Description\\n *   Get the RGB3 sensor ADC value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The ADC value of RGB3:0~255\\n * \\\\par Others\\n *   \\n */\\n\\tuint8_t getADCValueRGB3(void);\\n\\n/**\\n * \\\\par Function\\n *   getADCValueRGB4\\n * \\\\par Description\\n *   Get the RGB4 sensor ADC value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   The ADC value of RGB4:0~255\\n * \\\\par Others\\n *   \\n */\\n\\tuint8_t getADCValueRGB4(void);\\n\\n/**\\n * \\\\par Function\\n *   setKp\\n * \\\\par Description\\n *   set Kp.\\n * \\\\param[in]\\n *   value: 0 ~ 1，turn sensitivity\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n *  \\n */\\n\\tvoid setKp(float value);\\n\\n/**\\n * \\\\par Function\\n *   getPositionOffset\\n * \\\\par Description\\n *   get turn Value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Position offset Value,-512 ~ 512\\n      <0,in right\\n      >0,in left\\n * \\\\par Others\\n *   |---------------------------|\\n     |      |      |      |      |\\n     |RGB1  |RGB2  |RGB3  |RGB4  |\\n     |      |      |      |      |\\n     |---------------------------|\\n */\\n\\tint16_t getPositionOffset(void);\\n\\n\\n/**\\n * \\\\par Function\\n *   getPositionState\\n * \\\\par Description\\n *   get turn Value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Position StateValue,0x00~0x0F,bit0-RGB1,bit1-RGB2 ,bit2-RGB3  ,bit3-RGB4 \\n * \\\\par Others\\n *   |---------------------------|\\n     |      |      |      |      |\\n     |RGB1  |RGB2  |RGB3  |RGB4  |\\n     |      |      |      |      |\\n     |---------------------------|\\n */\\n\\tuint8_t getPositionState(void);\\n\\t\\n/**\\n   * \\\\par Function\\n   *   getStudyTypes\\n   * \\\\par Description\\n   *   get turn Value.\\n   * \\\\param[in]\\n   *   None\\n   * \\\\par Output\\n   *   None\\n   * \\\\return\\n   *   Study types\\n  *    0. STUDY_IDLE\\n  *    1. STUDY_BACKGROUND\\n  *    2. STUDY_TRACK\\n   * \\\\par Others\\n   */\\n  uint8_t getStudyTypes(void);\\n\\n/**\\n * \\\\par Function\\n *   updataAllSensorValue\\n * \\\\par Description\\n *   updata All Sensor Value.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   None\\n * \\\\par Others\\n */\\n\\tvoid updataAllSensorValue(void);\\n\\t\\n/**\\n   * \\\\par Function\\n   *   studyBackground\\n   * \\\\par Description\\n   *   study background.\\n   * \\\\param[in]\\n   *   None\\n   * \\\\par Output\\n   *   None\\n   * \\\\return\\n   *   Return the error code.\\n   *   the definition of the value of variable return_value:\\n   *   0:success\\n   *   1:BUFFER_LENGTH is shorter than size\\n   *   2:address send, nack received\\n   *   3:data send, nack received\\n   *   4:other twi error\\n   *   refer to the arduino official library twi.c\\n   * \\\\par Others\\n   */\\n  int8_t studyBackground(void);\\n\\n/**\\n * \\\\par Function\\n *   studyTrack\\n * \\\\par Description\\n *   study track.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n */\\n  int8_t studyTrack(void);\\n  \\n/**\\n * \\\\par Function\\n *   getThreshold\\n * \\\\par Description\\n *   Get the threshold between background and track.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the threshold. 0~255\\n * \\\\par Others\\n */\\nint8_t getThreshold(void);\\n\\n/**\\n * \\\\par Function\\n *   setRGBColour\\n * \\\\par Description\\n *   Set the RGB colour.\\n * \\\\param[in]\\n *   types:RGB_COLOUR_RED, RGB_COLOUR_GREEN, RGB_COLOUR_BLUE\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n */\\n int8_t setRGBColour(uint8_t colour);\\n\\n /**\\n  * \\\\par Function\\n  *   setBackgroundThreshold\\n  * \\\\par Description\\n  *   set Background Threshold.\\n  * \\\\param[in]\\n  *   ch:RGB index\\n  *      0.RGB1_INDEX\\n  *      1.RGB2_INDEX\\n  *      2.RGB3_INDEX\\n  *      3.RGB4_INDEX\\n  *   threshold:0~255\\n  * \\\\par Output\\n  *   None\\n  * \\\\return\\n  *   Return the error code.\\n  *   the definition of the value of variable return_value:\\n  *   0:success\\n  *   1:BUFFER_LENGTH is shorter than size\\n  *   2:address send, nack received\\n  *   3:data send, nack received\\n  *   4:other twi error\\n  *   refer to the arduino official library twi.c\\n  * \\\\par Others\\n  */\\n int8_t setBackgroundThreshold(uint8_t ch, uint8_t threshold);\\n \\n /**\\n  * \\\\par Function\\n  *   setTrackThreshold\\n  * \\\\par Description\\n  *   set track Threshold.\\n  * \\\\param[in]\\n  *   ch:RGB index\\n  *      0.RGB1_INDEX\\n  *      1.RGB2_INDEX\\n  *      2.RGB3_INDEX\\n  *      3.RGB4_INDEX\\n  *   threshold:0~255\\n  * \\\\par Output\\n  *   None\\n  * \\\\return\\n  *   Return the error code.\\n  *   the definition of the value of variable return_value:\\n  *   0:success\\n  *   1:BUFFER_LENGTH is shorter than size\\n  *   2:address send, nack received\\n  *   3:data send, nack received\\n  *   4:other twi error\\n  *   refer to the arduino official library twi.c\\n  * \\\\par Others\\n  */\\n int8_t setTrackThreshold(uint8_t ch, uint8_t threshold);\\n\\n/**\\n  * \\\\par Function\\n  *   getBackgroundThreshold\\n  * \\\\par Description\\n  *   Get the background threshold .\\n  * \\\\param[in]\\n  *   ch:RGB index\\n  *      0.RGB1_INDEX\\n  *      1.RGB2_INDEX\\n  *      2.RGB3_INDEX\\n  *      3.RGB4_INDEX\\n  * \\\\par Output\\n  *   None\\n  * \\\\return\\n  *   Return the background threshold. 0~255\\n  * \\\\par Others\\n  */\\n uint8_t getBackgroundThreshold(uint8_t ch);\\n \\n/**\\n * \\\\par Function\\n *   getTrackThreshold\\n * \\\\par Description\\n *   Get the track threshold .\\n * \\\\param[in]\\n *   ch:RGB index\\n *      0.RGB1_INDEX\\n *      1.RGB2_INDEX\\n *      2.RGB3_INDEX\\n *      3.RGB4_INDEX\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the track threshold. 0~255\\n * \\\\par Others\\n */\\nuint8_t getTrackThreshold(uint8_t ch);\\n\\n/**\\n * \\\\par Function\\n *   getFirmwareVersion\\n * \\\\par Description\\n *   Get Firmware Version.\\n * \\\\param[in]\\n *   None\\n * \\\\par Output\\n *   buffer: for storage version, length greater than 8\\n * \\\\return\\n *   None\\n * \\\\par Others\\n */\\nvoid getFirmwareVersion(char *buffer);\\n\\n/**\\n\\t * \\\\par Function\\n\\t *\\t loop\\n\\t * \\\\par Description\\n\\t *\\tRGBLineFollower loop.\\n\\t * \\\\param[in]\\n\\t *\\t None\\n\\t * \\\\par Output\\n\\t *\\t None\\n\\t * \\\\return\\n\\t *\\t \\n\\t * \\\\par Others\\n\\t */\\n  void loop(void);\\n\\nprivate:\\n  uint8_t i2cData[25];\\n  uint8_t adcOutput[RGBLINEFOLLOWER_NUM];\\n  uint8_t Device_Address;\\n  float Kp;\\n  int16_t positionOffset;\\n  uint8_t positionState;\\n  uint8_t study_types;\\n  uint32_t iic_error_count;\\n  unsigned long updata_time;\\n  \\n/**\\n * \\\\par Function\\n *   writeReg\\n * \\\\par Description\\n *   Write the registor of i2c device.\\n * \\\\param[in]\\n *   reg - the address of registor.\\n * \\\\param[in]\\n *   data - the data that will be written to the registor.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   To set the registor for initializing.\\n */\\n  int8_t writeReg(uint8_t reg, uint8_t data);\\n\\n/**\\n * \\\\par Function\\n *   readData\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to read data.\\n */\\n  int8_t readData(uint8_t start, uint8_t *buffer, uint8_t size);\\n\\n/**\\n * \\\\par Function\\n *   writeData\\n * \\\\par Description\\n *   Write the data to i2c device.\\n * \\\\param[in]\\n *   start - the address which will write the data to.\\n * \\\\param[in]\\n *   pData - the head address of data array.\\n * \\\\param[in]\\n *   size - set the number of data will be written to the devide.\\n * \\\\par Output\\n *   None\\n * \\\\return\\n *   Return the error code.\\n *   the definition of the value of variable return_value:\\n *   0:success\\n *   1:BUFFER_LENGTH is shorter than size\\n *   2:address send, nack received\\n *   3:data send, nack received\\n *   4:other twi error\\n *   refer to the arduino official library twi.c\\n * \\\\par Others\\n *   Calling the official i2c library to write data.\\n */\\n  int8_t writeData(uint8_t start, const uint8_t *pData, uint8_t size);\\n};\\n#endif //  MeRGBLineFollower_H\\n\" }"
];